CREATE ROLE x LOGIN SUPERUSER ; 
CREATE ROLE x ; 
CREATE ROLE x LOGIN NOSUPERUSER ; 
SET SESSION AUTHORIZATION 'x' ; 
SET client_min_messages = 'x' ; 
CREATE PUBLICATION testpub_default ; 
RESET client_min_messages ; 
COMMENT ON PUBLICATION testpub_default IS 'x' ; 
SELECT x ( x . x , 'x' ) FROM x p ; 
CREATE PUBLICATION testpub_xxx WITH ( foo ) ; 
CREATE PUBLICATION testpub_xxx WITH ( publish = 'x' ) ; 
ALTER PUBLICATION testpub_default SET ( publish = 'x' ) ; 
CREATE SCHEMA x ; 
CREATE TABLE x . testpub_nopk ( x INT , x INT ) ; 
CREATE VIEW x AS SELECT 1 ; 
CREATE TABLE x ( x INT ) PARTITION BY LIST ( a ) ; 
CREATE PUBLICATION testpub_foralltables FOR ALL TABLES WITH ( publish = 'x' ) ; 
ALTER PUBLICATION testpub_foralltables SET ( publish = 'x' ) ; 
ALTER PUBLICATION testpub_foralltables ADD TABLE x ; 
ALTER PUBLICATION testpub_foralltables DROP TABLE x ; 
ALTER PUBLICATION testpub_foralltables SET TABLE x . testpub_nopk ; 
SELECT x , x FROM x WHERE x = 'x' ; 
DROP TABLE x ; 
DROP PUBLICATION testpub_foralltables ; 
CREATE TABLE x ( x INT ) ; 
CREATE TABLE x ( x TEXT ) INHERITS ( x ) ; 
CREATE PUBLICATION testpub3 FOR TABLE x ; 
CREATE PUBLICATION testpub4 FOR TABLE ONLY x ; 
DROP TABLE x , x ; 
DROP PUBLICATION testpub3 , testpub4 ; 
CREATE PUBLICATION testpub_fortbl FOR TABLE x ; 
CREATE PUBLICATION testpub_fortbl FOR TABLE x , x . testpub_nopk ; 
ALTER PUBLICATION testpub_fortbl ADD TABLE x ; 
ALTER PUBLICATION testpub_default ADD TABLE x ; 
ALTER PUBLICATION testpub_default SET TABLE x ; 
ALTER PUBLICATION testpub_default ADD TABLE x . testpub_nopk ; 
ALTER PUBLICATION testpib_ins_trunct ADD TABLE x . testpub_nopk , x ; 
ALTER PUBLICATION testpub_default DROP TABLE x , x . testpub_nopk ; 
ALTER PUBLICATION testpub_default DROP TABLE x . testpub_nopk ; 
SET ROLE regress_publication_user2 ; 
GRANT CREATE ON DATABASE regression TO x ; 
GRANT regress_publication_user TO x ; 
SET ROLE regress_publication_user ; 
REVOKE CREATE ON DATABASE regression FROM x ; 
DROP VIEW x ; 
SET ROLE regress_publication_user_dummy ; 
ALTER PUBLICATION testpub_default RENAME TO testpub_dummy ; 
ALTER PUBLICATION testpub_default RENAME TO testpub_foo ; 
ALTER PUBLICATION testpub_foo RENAME TO testpub_default ; 
ALTER PUBLICATION testpub_default OWNER TO x ; 
DROP PUBLICATION testpub_default ; 
DROP PUBLICATION testpib_ins_trunct ; 
DROP PUBLICATION testpub_fortbl ; 
DROP SCHEMA pub_test CASCADE ; 
RESET SESSION AUTHORIZATION ; 
DROP ROLE x , x ; 
DROP ROLE x ; 
SET extra_float_digits TO 1 ; 
SELECT 'x' AS four , x ( x ) AS center FROM x ; 
@@SELECT 'x' AS four , ( x ) AS center FROM x ; 
SELECT 'x' AS six , x ( x ) AS center FROM x ; 
@@SELECT 'x' AS six , ( x ) AS center FROM x ; 
@@#SELECT 'x' AS two , ( x ) AS center FROM x WHERE ( x ) > 1 ; 
SELECT 'x' AS two , x . x FROM x p1 WHERE x ( x . x , x 'x' ) ; 
SELECT 'x' AS two , x . x FROM x p1 WHERE x . x ? - x 'x' ; 
SELECT 'x' AS one , x . x FROM x p1 WHERE x ( x . x , x 'x' ) ; 
SELECT 'x' AS one , x . x FROM x p1 WHERE x . x ? | x 'x' ; 
SELECT x . x , x . x , x ( x . x , x . x ) FROM x p1 , x p2 ; 
SELECT x . x , x . x , x . x + x . x FROM x p1 , x p2 ; 
SELECT x . x , x . x , x . x - x . x FROM x p1 , x p2 ; 
SELECT x . x , x . x , x . x * x . x FROM x p1 , x p2 WHERE x . x [ 1 ] BETWEEN 1 AND 1 ; 
SELECT x . x , x . x , x . x * x . x FROM x p1 , x p2 WHERE x . x [ 1 ] < 1 ; 
SELECT x . x , x . x , x . x / x . x FROM x p1 , x p2 WHERE x . x [ 1 ] BETWEEN 1 AND 1 ; 
SELECT x . x , x . x , x . x / x . x FROM x p1 , x p2 WHERE x . x [ 1 ] > 1 ; 
~######@SELECT x . x , x . x FROM x p , x l WHERE x . x < x . x ; 
@@SELECT x . x , x . x FROM x p , x p1 WHERE x . x < x . x ; 
SELECT x FROM x WHERE ? | x ; 
SELECT x FROM x WHERE ? - x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x = x . x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x ? || x . x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x ? - | x . x ; 
#SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x ? x . x ; 
#SELECT x . x , x . x FROM x l , x b WHERE x . x ? x . x ; 
######@@SELECT x , - x FROM x ; 
@@SELECT x , x FROM x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x < x . x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x <= x . x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x >= x . x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x > x . x ; 
SELECT x . x , x . x FROM x l1 , x l2 WHERE x . x != x . x ; 
#SELECT x . x , x . x FROM x l , x l1 WHERE x . x ? x . x ; 
########@SELECT x . x , x . x FROM x l , x l1 WHERE x . x < x . x ; 
@SELECT x . x , x . x FROM x l , x b WHERE x . x < x . x ; 
SELECT 'x' AS six , x ( x ) AS box FROM x ; 
SELECT 'x' AS twentyfour , x . x + x . x AS translation FROM x b , x p ; 
SELECT 'x' AS twentyfour , x . x - x . x AS translation FROM x b , x p ; 
SELECT x . x , x . x , x . x * x . x FROM x b , x p WHERE x . x [ 1 ] BETWEEN 1 AND 1 ; 
SELECT x . x , x . x , x . x * x . x FROM x b , x p WHERE x . x [ 1 ] > 1 ; 
SELECT x . x , x . x , x . x / x . x FROM x b , x p WHERE x . x [ 1 ] BETWEEN 1 AND 1 ; 
SELECT x ( x . x , x . x ) FROM x a , x b ; 
#SELECT x , x ( x ) FROM x ; 
@@@@SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x < x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x <= x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x = x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x >= x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x > x . x ; 
SELECT x . x , x . x , x . x + x . x FROM x p , x p1 ; 
SELECT x . x , x . x , x . x - x . x FROM x p , x p1 ; 
SELECT x . x , x . x , x . x * x . x FROM x p , x p1 ; 
SELECT x . x , x . x , x . x / x . x FROM x p , x p1 WHERE x . x [ 1 ] BETWEEN 1 AND 1 ; 
~@SELECT 'x' AS twentyfour , x . x , x . x , x . x > x . x AS contains FROM x poly , x p ; 
@SELECT 'x' AS twentyfour , x . x , x . x , x . x < x . x AS contained FROM x poly , x p ; 
SELECT 'x' AS four , x ( x ) AS npoints , x AS polygon FROM x ; 
SELECT 'x' AS four , x ( x ) FROM x ; 
SELECT 'x' AS four , x ( x ) FROM x WHERE x ( x ) ; 
SELECT 'x' AS four , x AS open_path , x ( x ( x ) ) AS polygon FROM x WHERE x ( x ) ; 
~@@SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x && x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x & < x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x & > x . x ; 
SELECT x . x , x . x FROM x p1 , x p2 WHERE x . x & < | x . x ; 
SELECT 'x' AS six , x ( x , 50.000000 ) FROM x ; 
#SELECT 'x' AS two , x ( x ) FROM x WHERE ( x ) >= 1 ; 
SELECT x , x ( 1 , x ) FROM x WHERE x >= 'x' ; 
SELECT x , x ( 1 , x ) FROM x WHERE x < 'x' ; 
~SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x = x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x && x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x & < x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x & > x . x ; 
@SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x < x . x ; 
@SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x > x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x & < | x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x != x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x <= x . x ; 
SELECT x . x , x . x FROM x c1 , x c2 WHERE x . x >= x . x ; 
SELECT x . x , x . x , x . x + x . x FROM x c , x p ; 
SELECT x . x , x . x , x . x - x . x FROM x c , x p ; 
SELECT x . x , x . x , x . x * x . x FROM x c , x p ; 
SELECT x . x , x . x , x . x / x . x FROM x c , x p WHERE x . x [ 1 ] BETWEEN 1 AND 1 ; 
SELECT x . x , x . x , x . x / x . x FROM x c , x p WHERE x . x [ 1 ] > 1 ; 
~CREATE TABLE x ( x int4 , x point ) ; 
CREATE INDEX x ON x USING spgist ( x ) WITH ( fillfactor = 1 ) ; 
INSERT INTO x ( x , x ) SELECT x , x ( x * 1 , x * 1 ) FROM x ( 1 , 1 ) g ; 
DELETE FROM x WHERE x < 1 ; 
VACUUM x ; 
INSERT INTO x ( x , x ) SELECT x + 1 , x ( x * 1 + 1 , x * 1 + 1 ) FROM x ( 1 , 1 ) g ; 
DELETE FROM x WHERE x % 1 = 1 ; 
CREATE TABLE x ( x serial , x box ) ; 
INSERT INTO x ( x ) SELECT x ( x ( x , x ) , x ( x + x , x + x ) ) FROM x ( 1 , 1 , 1 ) i , x ( 1 , 1 , 1 ) j , x ( 1 , 1 ) s ; 
CREATE INDEX x ON x USING spgist ( x ) ; 
SELECT x ( * ) FROM ( VALUES ( x ( 1 , 1 ) ) , ( x ( 1 , 1 ) ) , ( x ( 1 , 1 ) ) ) v ( p ) WHERE EXISTS ( SELECT * FROM x b WHERE x . x && x ( x . x , x . x ) ) ; 
CREATE TABLE x ( x int4 , x TEXT ) ; 
INSERT INTO x ( x , x ) SELECT - x , 'x' || x ( 'x' , 1 - x ) || 'x' FROM x ( 1 , 1 ) g ; 
ALTER INDEX x SET ( fillfactor = 1 ) ; 
REINDEX INDEX x ; 
BEGIN ; 
DECLARE foo13 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo14 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo15 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo16 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo17 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo18 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo19 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo20 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo21 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo22 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo23 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo24 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
DECLARE foo25 CURSOR FOR SELECT * FROM x WHERE x = 1 ; 
FETCH ALL IN foo13 ; 
FETCH ALL IN foo14 ; 
FETCH ALL IN foo15 ; 
FETCH ALL IN foo16 ; 
FETCH ALL IN foo17 ; 
FETCH ALL IN foo18 ; 
FETCH ALL IN foo19 ; 
FETCH ALL IN foo20 ; 
FETCH ALL IN foo21 ; 
FETCH ALL IN foo22 ; 
FETCH ALL IN foo23 ; 
FETCH ALL IN foo24 ; 
FETCH ALL IN foo25 ; 
CLOSE foo13 ; 
CLOSE foo14 ; 
CLOSE foo15 ; 
CLOSE foo16 ; 
CLOSE foo17 ; 
CLOSE foo18 ; 
CLOSE foo19 ; 
CLOSE foo20 ; 
CLOSE foo21 ; 
CLOSE foo22 ; 
CLOSE foo23 ; 
CLOSE foo24 ; 
CLOSE foo25 ; 
END ; 
DECLARE c1 CURSOR FOR SELECT * FROM x LIMIT 1 ; 
FETCH ALL IN c1 ; 
FETCH 1 IN c1 ; 
FETCH BACKWARD 1 IN c1 ; 
FETCH BACKWARD ALL IN c1 ; 
DECLARE c2 CURSOR FOR SELECT * FROM x LIMIT 1 ; 
FETCH ALL IN c2 ; 
FETCH 1 IN c2 ; 
FETCH BACKWARD 1 IN c2 ; 
FETCH BACKWARD ALL IN c2 ; 
DECLARE c3 CURSOR FOR SELECT * FROM x OFFSET 1 ; 
FETCH ALL IN c3 ; 
FETCH 1 IN c3 ; 
FETCH BACKWARD 1 IN c3 ; 
FETCH BACKWARD ALL IN c3 ; 
DECLARE c4 CURSOR FOR SELECT * FROM x OFFSET 1 ; 
FETCH ALL IN c4 ; 
FETCH 1 IN c4 ; 
FETCH BACKWARD 1 IN c4 ; 
FETCH BACKWARD ALL IN c4 ; 
ROLLBACK ; 
CREATE TEMP SEQUENCE x ; 
SELECT x , x , x ( 'x' ) FROM x ORDER BY x LIMIT 1 ; 
SELECT x ( 'x' ) ; 
SELECT x , x , x ( 1 , 1 ) FROM x ORDER BY x LIMIT 1 ; 
SELECT x ( x ) AS s1 , x ( x ) + x ( ) * 1 AS s2 FROM x GROUP BY x ORDER BY x LIMIT 1 ; 
SET client_min_messages TO 'x' ; 
DROP ROLE IF EXISTS x ; 
CREATE USER x ; 
SET search_path TO 'x' ; 
CREATE FOREIGN DATA WRAPPER addr_fdw ; 
CREATE SERVER addr_fserv FOREIGN DATA WRAPPER addr_fdw ; 
CREATE TEXT SEARCH TEMPLATE addr_ts_temp ( lexize = dsimple_lexize ) ; 
CREATE TABLE x . gentable ( x serial PRIMARY KEY CONSTRAINT a_chk CHECK ( x > 1 ) , x TEXT DEFAULT 'x' ) ; 
CREATE VIEW x . genview AS SELECT * FROM x . gentable ; 
CREATE MATERIALIZED VIEW x . genmatview AS SELECT * FROM x . gentable ; 
CREATE TYPE addr_nsp . gencomptype AS ( a INT ) ; 
CREATE TYPE addr_nsp . genenum AS ENUM ( 'x' , 'x' ) ; 
CREATE FOREIGN TABLE x . genftable ( x INT ) SERVER addr_fserv ; 
CREATE AGGREGATE addr_nsp . genaggr ( int4 ) ( sfunc = int4pl , stype = int4 ) ; 
CREATE TRIGGER x BEFORE INSERT ON x . gentable FOR EACH ROW EXECUTE PROCEDURE addr_nsp . trig ( ) ; 
CREATE POLICY genpol ON x . gentable ; 
CREATE SERVER integer" FOREIGN DATA WRAPPER addr_fdw ; 
CREATE USER MAPPING FOR x SERVER integer" ; 
ALTER DEFAULT PRIVILEGES FOR ROLE x IN SCHEMA public GRANT ALL ON TABLES TO x ; 
CREATE PUBLICATION addr_pub FOR TABLE x . gentable ; 
CREATE STATISTICS addr_nsp . gentable_stat ON x , x FROM x . gentable ; 
SELECT x ( 'x' , 'x' , 'x' ) ; 
$$$$SELECT * FROM x ( 'x' , 'x' , 'x' ) ; 
$$$$DROP FOREIGN DATA WRAPPER addr_fdw CASCADE ; 
DROP PUBLICATION addr_pub ; 
DROP SUBSCRIPTION regress_addr_sub ; 
DROP SCHEMA addr_nsp CASCADE ; 
DROP OWNED BY x ; 
DROP USER x ; 
DROP TABLE IF EXISTS x ; 
CREATE TABLE x ( x INT , x TEXT ) ; 
DROP VIEW IF EXISTS x ; 
CREATE VIEW x AS SELECT * FROM x ; 
DROP INDEX x ; 
DROP INDEX IF EXISTS x ; 
CREATE INDEX x ON x ( x ) ; 
DROP SEQUENCE x ; 
DROP SEQUENCE IF EXISTS x ; 
CREATE SEQUENCE x ; 
DROP SCHEMA test_schema_exists ; 
DROP SCHEMA IF EXISTS test_schema_exists ; 
DROP TYPE test_type_exists ; 
DROP TYPE IF EXISTS test_type_exists ; 
CREATE TYPE test_type_exists AS ( a INT , b TEXT ) ; 
DROP DOMAIN test_domain_exists ; 
DROP DOMAIN IF EXISTS test_domain_exists ; 
CREATE GROUP x ; 
DROP USER IF EXISTS x , x ; 
DROP ROLE IF EXISTS x , x ; 
DROP GROUP x ; 
DROP GROUP IF EXISTS x , x ; 
DROP COLLATION IF EXISTS x ; 
DROP CONVERSION x ; 
DROP CONVERSION IF EXISTS x ; 
CREATE CONVERSION test_conversion_exists FOR 'x' TO 'x' FROM iso8859_1_to_utf8 ; 
DROP TEXT SEARCH PARSER x ; 
DROP TEXT SEARCH PARSER IF EXISTS x ; 
DROP TEXT SEARCH DICTIONARY x ; 
DROP TEXT SEARCH DICTIONARY IF EXISTS x ; 
DROP TEXT SEARCH TEMPLATE x ; 
DROP TEXT SEARCH TEMPLATE IF EXISTS x ; 
DROP TEXT SEARCH CONFIGURATION x ; 
DROP TEXT SEARCH CONFIGURATION IF EXISTS x ; 
DROP EXTENSION test_extension_exists ; 
DROP EXTENSION IF EXISTS test_extension_exists ; 
DROP FUNCTION x ( ) ; 
DROP FUNCTION IF EXISTS x ( ) ; 
DROP FUNCTION x ( INT , TEXT , INT [ ] ) ; 
DROP FUNCTION IF EXISTS x ( INT , TEXT , INT [ ] ) ; 
DROP AGGREGATE x ( * ) ; 
DROP AGGREGATE IF EXISTS x ( * ) ; 
DROP AGGREGATE x ( INT ) ; 
DROP AGGREGATE IF EXISTS x ( INT ) ; 
@#@@#@@#@@#@DROP LANGUAGE test_language_exists ; 
DROP LANGUAGE IF EXISTS test_language_exists ; 
DROP CAST ( TEXT AS TEXT ) ; 
DROP CAST IF EXISTS ( TEXT AS TEXT ) ; 
DROP TRIGGER test_trigger_exists ON test_exists ; 
DROP TRIGGER IF EXISTS test_trigger_exists ON test_exists ; 
DROP TRIGGER test_trigger_exists ON no_such_table ; 
DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_table ; 
DROP TRIGGER test_trigger_exists ON no_such_schema . no_such_table ; 
DROP TRIGGER IF EXISTS test_trigger_exists ON no_such_schema . no_such_table ; 
CREATE TRIGGER x BEFORE UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
DROP RULE test_rule_exists ON test_exists ; 
DROP RULE IF EXISTS test_rule_exists ON test_exists ; 
DROP RULE test_rule_exists ON no_such_table ; 
DROP RULE IF EXISTS test_rule_exists ON no_such_table ; 
DROP RULE test_rule_exists ON no_such_schema . no_such_table ; 
DROP RULE IF EXISTS test_rule_exists ON no_such_schema . no_such_table ; 
DROP FOREIGN DATA WRAPPER test_fdw_exists ; 
DROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists ; 
DROP SERVER test_server_exists ; 
DROP SERVER IF EXISTS test_server_exists ; 
DROP OPERATOR CLASS test_operator_class USING btree ; 
DROP OPERATOR CLASS IF EXISTS test_operator_class USING btree ; 
DROP OPERATOR CLASS test_operator_class USING no_such_am ; 
DROP OPERATOR CLASS IF EXISTS test_operator_class USING no_such_am ; 
DROP OPERATOR FAMILY test_operator_family USING btree ; 
DROP OPERATOR FAMILY IF EXISTS test_operator_family USING btree ; 
DROP OPERATOR FAMILY test_operator_family USING no_such_am ; 
DROP OPERATOR FAMILY IF EXISTS test_operator_family USING no_such_am ; 
DROP ACCESS METHOD no_such_am ; 
DROP ACCESS METHOD IF EXISTS no_such_am ; 
DROP AGGREGATE IF EXISTS no_such_schema . foo ( INT ) ; 
DROP AGGREGATE IF EXISTS x ( no_such_type ) ; 
DROP AGGREGATE IF EXISTS x ( no_such_schema . no_such_type ) ; 
DROP CAST IF EXISTS ( INTEGER AS no_such_type2 ) ; 
DROP CAST IF EXISTS ( no_such_type1 AS INTEGER ) ; 
DROP CAST IF EXISTS ( INTEGER AS no_such_schema . bar ) ; 
DROP CAST IF EXISTS ( no_such_schema . foo AS INTEGER ) ; 
DROP COLLATION IF EXISTS x . foo ; 
DROP CONVERSION IF EXISTS x . foo ; 
DROP DOMAIN IF EXISTS no_such_schema . foo ; 
DROP FOREIGN TABLE IF EXISTS x . foo ; 
DROP FUNCTION IF EXISTS no_such_schema . foo ( ) ; 
DROP FUNCTION IF EXISTS x ( no_such_type ) ; 
DROP FUNCTION IF EXISTS x ( no_such_schema . no_such_type ) ; 
DROP INDEX IF EXISTS x . foo ; 
DROP MATERIALIZED VIEW IF EXISTS x . foo ; 
DROP OPERATOR IF EXISTS no_such_schema . + ( INT , INT ) ; 
DROP OPERATOR IF EXISTS + ( no_such_type , no_such_type ) ; 
DROP OPERATOR IF EXISTS + ( no_such_schema . no_such_type , no_such_schema . no_such_type ) ; 
#DROP OPERATOR CLASS IF EXISTS no_such_schema . widget_ops USING btree ; 
DROP OPERATOR FAMILY IF EXISTS no_such_schema . float_ops USING btree ; 
DROP RULE IF EXISTS foo ON no_such_schema . bar ; 
DROP SEQUENCE IF EXISTS x . foo ; 
DROP TABLE IF EXISTS x . foo ; 
DROP TEXT SEARCH CONFIGURATION IF EXISTS x . foo ; 
DROP TEXT SEARCH DICTIONARY IF EXISTS x . foo ; 
DROP TEXT SEARCH PARSER IF EXISTS x . foo ; 
DROP TEXT SEARCH TEMPLATE IF EXISTS x . foo ; 
DROP TRIGGER IF EXISTS foo ON no_such_schema . bar ; 
DROP TYPE IF EXISTS no_such_schema . foo ; 
DROP VIEW IF EXISTS x . foo ; 
$$$$DROP FUNCTION test_ambiguous_funcname ; 
DROP FUNCTION IF EXISTS test_ambiguous_funcname ; 
DROP FUNCTION x ( INT ) ; 
DROP FUNCTION x ( TEXT ) ; 
$$$$DROP PROCEDURE test_ambiguous_procname ; 
DROP PROCEDURE IF EXISTS test_ambiguous_procname ; 
DROP ROUTINE IF EXISTS test_ambiguous_procname ; 
DROP PROCEDURE x ( INT ) ; 
DROP PROCEDURE x ( TEXT ) ; 
DROP DATABASE x ( FORCE ) ; 
DROP DATABASE x WITH ( FORCE ) ; 
DROP DATABASE IF EXISTS x ( FORCE ) ; 
DROP DATABASE IF EXISTS x WITH ( FORCE ) ; 
CREATE TYPE mood AS ENUM ( 'x' , 'x' , 'x' ) ; 
DROP TYPE mood ; 
CREATE TABLE x ( x int8 , x int8 ) ; 
INSERT INTO x VALUES ( 'x' , 'x' ) ; 
INSERT INTO x VALUES ( + 1 , 'x' ) ; 
INSERT INTO x ( x ) VALUES ( 'x' ) ; 
SELECT * FROM x ; 
SELECT * FROM x WHERE x = 1 ; 
SELECT * FROM x WHERE x < 1 ; 
SELECT * FROM x WHERE x > 1 ; 
SELECT * FROM x WHERE x <= 1 ; 
SELECT * FROM x WHERE x >= 1 ; 
SELECT * FROM x WHERE 1 = x ; 
SELECT * FROM x WHERE 1 < x ; 
SELECT * FROM x WHERE 1 > x ; 
SELECT * FROM x WHERE 1 <= x ; 
SELECT * FROM x WHERE 1 >= x ; 
SELECT 'x' AS five , x AS plus , - x AS minus FROM x ; 
SELECT 'x' AS five , x , x , x + x AS plus FROM x ; 
SELECT 'x' AS five , x , x , x - x AS minus FROM x ; 
SELECT 'x' AS three , x , x , x * x AS multiply FROM x ; 
SELECT 'x' AS three , x , x , x * x AS multiply FROM x WHERE x < 1 OR ( x > 1 AND x < 1 ) ; 
SELECT 'x' AS five , x , x , x / x AS divide , x % x AS mod FROM x ; 
SELECT 'x' AS five , x , x ( x ) FROM x ; 
SELECT 1 + x AS plus4 FROM x ; 
SELECT 1 - x AS minus4 FROM x ; 
SELECT 'x' AS five , 1 * x AS twice int4" FROM x ; 
SELECT 'x' AS five , x * 1 AS twice int4" FROM x ; 
SELECT x ( x ) , x ( x ) FROM x ; 
SELECT 'x' AS to_char_1 , x ( x , 'x' ) , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_2 , x ( x , 'x' ) , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_3 , x ( ( x * 1 ) , 'x' ) , x ( ( x * 1 ) , 'x' ) FROM x ; 
SELECT 'x' AS to_char_4 , x ( ( x * 1 ) , 'x' ) , x ( ( x * 1 ) , 'x' ) FROM x ; 
SELECT 'x' AS to_char_5 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_6 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_7 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_8 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_9 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_10 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_11 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_12 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_13 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_14 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_15 , x ( x , 'x' ) FROM x ; 
SELECT 'x' AS to_char_16 , x ( x , x 'x' ) FROM x ; 
SELECT 'x' AS to_char_17 , x ( x , 'x' ) FROM x ; 
SELECT CAST ( x AS int4 ) FROM x WHERE x = 1 ; 
SELECT CAST ( x AS int2 ) FROM x WHERE x = 1 ; 
SELECT CAST ( x AS float4 ) , CAST ( x AS float8 ) FROM x ; 
SELECT CAST ( x AS oid ) FROM x ; 
#ANALYZE x ; 
SELECT x , EXTRACT ( YEAR FROM x ) , x ( * ) FROM x GROUP BY 1 , 1 ORDER BY 1 , 1 ; 
\CREATE TABLE x ( x INT , x INT , x TEXT ) ; 
INSERT INTO x SELECT 1 , x , 'x' || x FROM x ( 1 , 1 ) x ; 
\CREATE TYPE complex AS ( r float8 , i float8 ) ; 
CREATE TYPE quad AS ( c1 complex , c2 complex ) ; 
INSERT INTO x VALUES ( 1 , ( ( 3.300000 , 4.400000 ) , ( 5.500000 , 6.600000 ) ) ) ; 
INSERT INTO x VALUES ( 1 , ( ( NULL , 4.400000 ) , ( 5.500000 , 6.600000 ) ) ) ; 
CREATE TEMP TABLE x ( x fullname , x date ) ; 
ALTER TABLE x ADD COLUMN x TEXT DEFAULT 'x' ; 
ALTER TABLE x ADD COLUMN x TEXT DEFAULT NULL ; 
UPDATE x SET x . suffix = 'x' ; 
INSERT INTO x ( x , x . c1 . r , x . c2 . i ) VALUES ( 1 , 1 , 1 ) ; 
CREATE TEMP TABLE x ( x TEXT ) ; 
INSERT INTO x VALUES ( x ( 'x' , 1 ) ) ; 
~~~~~~SELECT ROW ( 1 , 1 ) IN ( ROW ( 1 , 1 ) , ROW ( 1 , 1 ) ) ; 
CREATE TEMP TABLE x ( x TEXT , x TEXT ) ; 
INSERT INTO x SELECT 'x' , NULL FROM x ( 1 , 1 ) ; 
CREATE INDEX ON x ( x , x ) ; 
SET enable_sort = off ; 
EXPLAIN ( costs off ) SELECT x , x FROM x WHERE ( x , x ) > ( 'x' , 'x' ) ORDER BY x , x ; 
SELECT x , x FROM x WHERE ( x , x ) > ( 'x' , 'x' ) ORDER BY x , x ; 
RESET enable_sort ; 
SELECT ( ROW ( 1 , 2.000000 ) ) . f1 ; 
SELECT ( ROW ( 1 , 2.000000 ) ) . f2 ; 
SELECT ( x ) . f1 FROM ( SELECT ROW ( 1 , 2.000000 ) AS r ) ss ; 
SELECT ROW ( ) ; 
SELECT ROW ( ) IS NULL ; 
SELECT ROW ( ) = ROW ( ) ; 
SELECT ARRAY [ ROW ( 1 , 1 ) , ROW ( 1 , 1 ) , ROW ( 1 , 1 ) ] ; 
SELECT ROW ( 1 , 1.100000 ) = ANY ( ARRAY [ ROW ( 1 , 7.700000 ) , ROW ( 1 , 1.100000 ) , ROW ( 1 , 0.000000 ) ] ) ; 
SELECT ROW ( 1 , 1.100000 ) = ANY ( ARRAY [ ROW ( 1 , 7.700000 ) , ROW ( 1 , 1.000000 ) , ROW ( 1 , 0.000000 ) ] ) ; 
CREATE TYPE cantcompare AS ( p point , r float8 ) ; 
CREATE TEMP TABLE x ( x cantcompare ) ; 
INSERT INTO x VALUES ( 'x' ) ; 
CREATE TYPE testtype3 AS ( a INT , b TEXT ) ; 
CREATE TYPE testtype5 AS ( a INT ) ; 
CREATE TYPE testtype6 AS ( a INT , b point ) ; 
DROP TYPE testtype1 , testtype3 , testtype5 , testtype6 ; 
CREATE TYPE testtype1 AS ( a INT , b INT ) ; 
SELECT x . x , x . x = ROW ( 1 ) , x . x = ARRAY [ ROW ( 1 ) ] , x . x = ROW ( ROW ( 1 ) ) FROM x ( ARRAY [ ROW ( 1 , ROW ( 1 ) , ARRAY [ ROW ( 1 ) ] , ROW ( ROW ( 1 ) ) ) , ROW ( 1 , ROW ( 1 ) , ARRAY [ ROW ( 1 ) ] , ROW ( ROW ( 1 ) ) ) ] ) AS q ( a INT , b record , c record [ ] , d record ) ; 
DROP TYPE testtype1 , testtype2 , testtype3 , testtype4 , testtype5 , testtype6 ; 
CREATE TABLE x ( x SERIAL PRIMARY KEY , x BOOLEAN NOT NULL , x NUMERIC ) ; 
CREATE TYPE price_input AS ( id INTEGER , price NUMERIC ) ; 
CREATE TYPE price_key AS ( id INTEGER ) ; 
$$$$INSERT INTO x VALUES ( 1 , FALSE , 1 ) , ( 1 , FALSE , 1 ) , ( 1 , TRUE , 17.990000 ) ; 
CREATE TEMP TABLE x ( x INT , x TEXT ) ; 
$$$$$$$$$$$$$$SELECT x ( ROW ( 1 , 'x' ) ) ; 
SELECT CAST ( x AS TEXT ) FROM x ; 
$$SELECT x . x FROM x f ; 
SELECT x ( x ) FROM x f ; 
ALTER TABLE x ADD COLUMN x TEXT ; 
SELECT x ( x ) FROM x i ; 
SELECT x ( x ) FROM x i ( x , y ) ; 
CREATE TEMP VIEW x AS SELECT * FROM x ; 
SELECT x ( x ) FROM ( SELECT x , x FROM x ) AS ss ; 
SELECT x ( x ) FROM ( SELECT x , x FROM x OFFSET 1 ) AS ss ; 
SELECT x ( x ) FROM ( SELECT x AS a , x AS b FROM x ) AS ss ; 
SELECT x ( x ) FROM ( SELECT x AS a , x AS b FROM x OFFSET 1 ) AS ss ; 
SELECT x ( x ) FROM ( SELECT x AS a , x AS b FROM x ) AS ss ( x , y ) ; 
SELECT x ( x ) FROM ( SELECT x AS a , x AS b FROM x OFFSET 1 ) AS ss ( x , y ) ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM ( SELECT x , x FROM x WHERE x = 1 AND x < 1 OFFSET 1 ) q ; 
SELECT x ( x ) FROM ( SELECT x , x FROM x WHERE x = 1 AND x < 1 OFFSET 1 ) q ; 
SELECT x ( x ) FROM ( SELECT x AS x , x AS y FROM x WHERE x = 1 AND x < 1 OFFSET 1 ) q ; 
SELECT x ( x ) FROM ( SELECT x AS x , x AS y FROM x WHERE x = 1 AND x < 1 OFFSET 1 ) q ( a , b ) ; 
CREATE TEMP TABLE x AS SELECT * FROM x LIMIT 1 ; 
CREATE TEMP TABLE x ( ) INHERITS ( x ) ; 
INSERT INTO x VALUES ( 1 , 1 ) ; 
SELECT x ( x ) FROM ( SELECT x , x FROM x OFFSET 1 ) r ; 
CREATE TABLE x ( x TEXT , x TEXT ) ; 
INSERT INTO x ( x , x ) VALUES ( 'x' , 'x' ) ; 
SELECT x . x FROM ( SELECT x AS d FROM x ) s ; 
SELECT ( x ) . a , ( x ) . b FROM ( SELECT x AS d FROM x ) s ; 
SELECT ( x ) . ctid FROM ( SELECT x AS d FROM x ) s ; 
SELECT x ( * ) AS should_be_1 FROM x ; 
SELECT x ( * ) AS should_be_2 FROM x ; 
SELECT x ( * ) AS should_be_3 FROM x ; 
COPY x TO 'x' ; 
\BEGIN TRANSACTION READ ONLY ; 
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ ; 
COMMIT ; 
ABORT ; 
START TRANSACTION ; 
SAVEPOINT s ; 
RELEASE SAVEPOINT s ; 
ROLLBACK TO SAVEPOINT s ; 
SET synchronous_commit = ON ; 
SHOW synchronous_commit ; 
RESET synchronous_commit ; 
DISCARD TEMP ; 
DISCARD ALL ; 
DECLARE hsc CURSOR FOR SELECT * FROM x ; 
FETCH NEXT FROM hsc ; 
FETCH FIRST FROM hsc ; 
FETCH LAST FROM hsc ; 
FETCH 1 FROM hsc ; 
CLOSE hsc ; 
PREPARE hsp AS SELECT x ( * ) FROM x ; 
$PREPARE hsp_noexec ( INTEGER ) AS INSERT INTO x VALUES ( 1 ) ; 
EXECUTE hsp ; 
DEALLOCATE hsp ; 
LOCK x IN ACCESS SHARE MODE ; 
LOCK x IN ROW SHARE MODE ; 
LOCK x IN ROW EXCLUSIVE MODE ; 
UNLISTEN a ; 
UNLISTEN * ; 
CHECKPOINT ; 
SELECT x ( ) ; 
SELECT x ( x ( ) ) ; 
_CREATE AGGREGATE x ( sfunc = int4_avg_accum , basetype = int4 , stype = int8 , finalfunc = int8_avg , initcond1 = 'x' ) ; 
COMMENT ON AGGREGATE x ( int4 ) IS 'x' ; 
COMMENT ON AGGREGATE x ( int4 ) IS NULL ; 
CREATE AGGREGATE x ( sfunc1 = int4pl , basetype = int4 , stype1 = int4 , initcond1 = 'x' ) ; 
CREATE AGGREGATE x ( sfunc = int8inc , basetype = 'x' , stype = int8 , initcond = 'x' ) ; 
CREATE AGGREGATE x ( any" ) ( sfunc = int8inc_any , stype = int8 , initcond = 'x' ) ; 
COMMENT ON AGGREGATE x ( * ) IS 'x' ; 
COMMENT ON AGGREGATE x ( any" ) IS 'x' ; 
CREATE AGGREGATE x ( int8 , int8 ) ( sfunc = sum3 , stype = int8 , initcond = 'x' ) ; 
CREATE TYPE aggtype AS ( a INTEGER , b INTEGER , c TEXT ) ; 
CREATE AGGREGATE x ( INTEGER , INTEGER , TEXT ) ( sfunc = aggf_trans , stype = aggtype [ ] , initcond = 'x' ) ; 
CREATE AGGREGATE x ( INTEGER , INTEGER , TEXT ) ( sfunc = aggfns_trans , stype = aggtype [ ] , sspace = 1 , initcond = 'x' ) ; 
CREATE AGGREGATE x ( VARIADIC items anyarray ) ( stype = anyelement , sfunc = least_accum ) ; 
ALTER AGGREGATE x ( float8 ORDER BY anyelement ) RENAME TO test_percentile_disc ; 
ALTER AGGREGATE x ( VARIADIC any" ORDER BY VARIADIC any" ) RENAME TO test_rank ; 
DROP AGGREGATE x ( NUMERIC ) ; 
DROP FUNCTION x ( int8 , int8 , int8 , int8 ) ; 
$$$$CREATE TABLE x ( x INTEGER PRIMARY KEY ) ; 
INSERT INTO x VALUES ( 1 ) ; 
@SELECT x 'x' ? 'x' ; 
@@@@@@@@@@@@@@@@@@@SELECT x ( 'x' , 'x' ) ; 
SELECT x ( 'x' , 'x' , silent => TRUE ) ; 
@@@@@@@@@@@@@@@@SELECT x ( 'x' , 'x' , silent => FALSE ) ; 
SELECT * FROM x ( 'x' , 'x' ) ; 
@@@@@@@@@@@@@SELECT x , x , x ( 'x' , 'x' , x ( 'x' , x , 'x' , x ) ) AS x && y" FROM ( VALUES ( x 'x' ) , ( 'x' ) , ( 'x' ) ) x ( x ) , ( VALUES ( x 'x' ) , ( 'x' ) , ( 'x' ) ) y ( y ) ; 
SELECT x , x , x ( 'x' , 'x' , x ( 'x' , x , 'x' , x ) ) AS x || y" FROM ( VALUES ( x 'x' ) , ( 'x' ) , ( 'x' ) ) x ( x ) , ( VALUES ( x 'x' ) , ( 'x' ) , ( 'x' ) ) y ( y ) ; 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@SET TIME ZONE 'x' ; 
SET TIME ZONE DEFAULT ; 
SELECT x ( 'x' , 'x' , vars => 'x' ) ; 
@@@@@@CREATE TABLE x ( x TEXT ) ; 
SELECT 'x' AS two , * FROM x ; 
SELECT x ( 1 ) ; 
SELECT 'x' || 1 + 1 ; 
SELECT 1 || 4.000000 ; 
SELECT x ( 1 , 1 , 1 , 'x' , TRUE , FALSE , x ( 'x' , 'x' ) ) ; 
SELECT x ( 'x' , 1 , 1 , 1 , 'x' , TRUE , FALSE , x ( 'x' , 'x' ) ) ; 
SELECT x ( 'x' , 1 , 1 , NULL , 1 ) ; 
SELECT x ( NULL , 1 , 1 , NULL , 1 ) IS NULL ; 
SELECT x ( x 'x' ) ; 
SELECT x ( VARIADIC ARRAY [ 1 , 1 , 1 ] ) ; 
SELECT x ( 'x' , VARIADIC ARRAY [ 1 , 1 , 1 ] ) ; 
SELECT x ( 'x' , VARIADIC 1 ) ; 
SELECT x ( 'x' , 1 ) ; 
SELECT x ( 'x' , 'x' , 1 , 'x' ) ; 
SELECT x ( 'x' , 'x' , NULL , 'x' ) ; 
SELECT x ( 'x' , 'x' , 1 , NULL ) ; 
SELECT x ( 'x' , NULL , 1 , 'x' ) ; 
SELECT x ( 'x' , 1 , 1 , 1 ) ; 
SELECT x ( 'x' , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ) ; 
SELECT x ( 'x' , VARIADIC ARRAY [ 'x' , 'x' ] ) ; 
SELECT x ( 'x' , VARIADIC ARRAY [ 1 , 1 ] ) ; 
SELECT x ( 'x' , VARIADIC ARRAY [ TRUE , FALSE ] ) ; 
SELECT x ( x ( 'x' , 'x' ) , VARIADIC x ( x ) ) FROM x ( 1 , 1 ) g ( i ) ; 
SELECT x ( 'x' , NULL ) ; 
SELECT x ( 'x' , 1 , 'x' ) ; 
SELECT x ( 'x' , 1 , NULL ) ; 
SELECT x ( 'x' , NULL , 'x' ) ; 
CREATE TYPE shell ; 
CREATE TYPE int42 ; 
CREATE TYPE text_w_default ; 
CREATE FUNCTION x ( cstring ) RETURNS int42 AS 'x' LANGUAGE internal STRICT IMMUTABLE ; 
CREATE FUNCTION x ( int42 ) RETURNS cstring AS 'x' LANGUAGE internal STRICT IMMUTABLE ; 
CREATE FUNCTION x ( cstring ) RETURNS text_w_default AS 'x' LANGUAGE internal STRICT IMMUTABLE ; 
CREATE FUNCTION x ( text_w_default ) RETURNS cstring AS 'x' LANGUAGE internal STRICT IMMUTABLE ; 
CREATE TABLE x ( x text_w_default , x int42 ) ; 
INSERT INTO x DEFAULT VALUES ; 
CREATE TYPE case_int42 ( Internallength" = 1 , Input" = int42_in , Output" = int42_out , Alignment" = int4 , Default" = 1 , Passedbyvalue" ) ; 
CREATE TYPE default_test_row AS ( f1 text_w_default , f2 int42 ) ; 
SELECT * FROM x ( ) ; 
COMMENT ON TYPE bad IS 'x' ; 
COMMENT ON TYPE default_test_row IS 'x' ; 
COMMENT ON TYPE default_test_row IS NULL ; 
COMMENT ON COLUMN default_test_row . nope IS 'x' ; 
COMMENT ON COLUMN default_test_row . f1 IS 'x' ; 
COMMENT ON COLUMN default_test_row . f1 IS NULL ; 
CREATE FUNCTION x ( cstring ) RETURNS opaque AS 'x' LANGUAGE internal IMMUTABLE STRICT ; 
CREATE FUNCTION x ( opaque ) RETURNS opaque AS 'x' LANGUAGE internal IMMUTABLE STRICT ; 
INSERT INTO x VALUES ( 'x' ) , ( 'x' ) ; 
TABLE x ; 
CREATE DOMAIN domaindroptest int4 ; 
COMMENT ON DOMAIN domaindroptest IS 'x' ; 
CREATE DOMAIN dependenttypetest domaindroptest ; 
DROP DOMAIN domaindroptest ; 
DROP DOMAIN domaindroptest CASCADE ; 
CREATE DOMAIN domainvarchar VARCHAR ( 1 ) ; 
CREATE DOMAIN domainnumeric NUMERIC ( 1 , 1 ) ; 
CREATE DOMAIN domainint4 int4 ; 
CREATE DOMAIN domaintext TEXT ; 
SELECT CAST ( 'x' AS domainvarchar ) ; 
CREATE TABLE x ( x domainint4 , x domaintext , x domainvarchar , x domainnumeric ) ; 
DROP DOMAIN domainvarchar RESTRICT ; 
DROP DOMAIN domainnumeric RESTRICT ; 
DROP DOMAIN domainint4 RESTRICT ; 
DROP DOMAIN domaintext ; 
CREATE DOMAIN domainint4arr int4 [ 1 ] ; 
CREATE DOMAIN domainchar4arr VARCHAR ( 1 ) [ 1 ] [ 1 ] ; 
CREATE TABLE x ( x domainint4arr , x domainchar4arr ) ; 
INSERT INTO x VALUES ( NULL , 'x' ) ; 
INSERT INTO x ( x [ 1 ] , x [ 1 ] ) VALUES ( 1 , 1 ) ; 
SELECT x [ 1 ] , x [ 1 : 1 ] FROM x ; 
COPY x FROM STDIN ; 
{UPDATE x SET x [ 1 ] = x [ 1 ] + 1 , x [ 1 ] = x [ 1 ] - 1 WHERE x IS NULL ; 
SELECT * FROM x WHERE x IS NULL ; 
DROP DOMAIN domainint4arr RESTRICT ; 
DROP DOMAIN domainchar4arr RESTRICT ; 
CREATE DOMAIN dia AS INT [ ] ; 
CREATE TYPE comptype AS ( r float8 , i float8 ) ; 
CREATE DOMAIN dcomptype AS comptype ; 
CREATE TABLE x ( x dcomptype UNIQUE ) ; 
SELECT ( x ) . r , ( x ) . i , ( x ) . * FROM x ; 
UPDATE x SET x . r = ( x ) . r + 1 WHERE ( x ) . i > 1 ; 
INSERT INTO x ( x . r , x . i ) VALUES ( 1 , 1 ) ; 
CREATE RULE silly AS ON DELETE TO x DO INSTEAD UPDATE x SET x . r = ( x ) . r - 1 , x . i = ( x ) . i + 1 WHERE ( x ) . i > 1 ; 
DROP TYPE comptype CASCADE ; 
COMMENT ON CONSTRAINT c1 ON DOMAIN dcomptype IS 'x' ; 
CREATE DOMAIN dcomptypea AS comptype [ ] ; 
CREATE TABLE x ( x dcomptypea UNIQUE ) ; 
INSERT INTO x ( x [ 1 ] . r ) VALUES ( 1 ) ; 
SELECT x [ 1 ] , x [ 1 ] . x , x [ 1 ] . x FROM x ; 
UPDATE x SET x [ 1 ] = ROW ( x [ 1 ] . x , x [ 1 ] . x ) ; 
UPDATE x SET x [ 1 ] . r = x [ 1 ] . x + 1 WHERE x [ 1 ] . x > 1 ; 
INSERT INTO x ( x [ 1 ] . r , x [ 1 ] . i ) VALUES ( 1 , 1 ) ; 
CREATE RULE silly AS ON DELETE TO x DO INSTEAD UPDATE x SET x [ 1 ] . r = x [ 1 ] . x - 1 , x [ 1 ] . i = x [ 1 ] . x + 1 WHERE x [ 1 ] . x > 1 ; 
CREATE TABLE x ( x posint [ ] ) ; 
INSERT INTO x VALUES ( ARRAY [ 1 ] ) ; 
CREATE DOMAIN vc4 AS VARCHAR ( 1 ) ; 
CREATE TABLE x ( x vc4 [ ] ) ; 
DROP TYPE vc4 ; 
CREATE DOMAIN dposinta AS posint [ ] ; 
CREATE TABLE x ( x dposinta [ ] ) ; 
SELECT x ( x ) FROM x ; 
SELECT x ( x [ 1 ] ) FROM x ; 
SELECT x ( x [ 1 ] [ 1 ] ) FROM x ; 
SELECT x ( ( x [ 1 ] ) [ 1 ] ) FROM x ; 
UPDATE x SET x [ 1 ] = ARRAY [ 1 ] ; 
SELECT x , x [ 1 ] , ( x [ 1 ] ) [ 1 ] FROM x ; 
UPDATE x SET x [ 1 ] [ 1 ] = ARRAY [ 1 ] ; 
DROP DOMAIN posint CASCADE ; 
CREATE DOMAIN dnotnull VARCHAR ( 1 ) NOT NULL ; 
CREATE DOMAIN dnull VARCHAR ( 1 ) ; 
INSERT INTO x VALUES ( 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
INSERT INTO x VALUES ( NULL , 'x' , 'x' , 'x' , 'x' ) ; 
INSERT INTO x VALUES ( 'x' , NULL , 'x' , 'x' , 'x' ) ; 
INSERT INTO x VALUES ( 'x' , 'x' , NULL , 'x' , 'x' ) ; 
SELECT CAST ( 'x' AS dnotnull ) ; 
DROP DOMAIN dnotnull RESTRICT ; 
DROP DOMAIN dnull RESTRICT ; 
DROP DOMAIN dcheck RESTRICT ; 
CREATE DOMAIN ddef1 int4 DEFAULT 1 ; 
CREATE DOMAIN ddef2 oid DEFAULT 'x' ; 
CREATE DOMAIN ddef3 TEXT DEFAULT 1 ; 
CREATE DOMAIN ddef4 int4 DEFAULT x ( 'x' ) ; 
CREATE DOMAIN ddef5 NUMERIC ( 1 , 1 ) NOT NULL DEFAULT 'x' ; 
CREATE TABLE x ( x ddef1 , x ddef2 , x ddef3 , x ddef4 PRIMARY KEY , x ddef1 NOT NULL DEFAULT NULL , x ddef2 DEFAULT 'x' , x ddef4 DEFAULT 1 , x ddef5 ) ; 
COPY x ( x ) FROM STDIN ; 
DROP TABLE x CASCADE ; 
CREATE DOMAIN dnotnulltest INTEGER ; 
CREATE TABLE x ( x dnotnulltest , x dnotnulltest ) ; 
ALTER DOMAIN dnotnulltest SET NOT NULL ; 
UPDATE x SET x = NULL ; 
DROP DOMAIN dnotnulltest CASCADE ; 
CREATE TABLE x ( x ddef1 ) ; 
ALTER DOMAIN ddef1 SET DEFAULT 'x' ; 
ALTER DOMAIN ddef1 DROP DEFAULT ; 
CREATE DOMAIN con AS INTEGER ; 
CREATE TABLE x ( x con ) ; 
ALTER DOMAIN con DROP CONSTRAINT t ; 
ALTER DOMAIN con DROP CONSTRAINT nonexistent ; 
ALTER DOMAIN con DROP CONSTRAINT IF EXISTS nonexistent ; 
CREATE DOMAIN things AS INT ; 
CREATE TABLE x ( x things ) ; 
INSERT INTO x ( x ) VALUES ( 1 ) ; 
ALTER DOMAIN things VALIDATE CONSTRAINT meow ; 
UPDATE x SET x = 1 ; 
CREATE TABLE x ( x INTEGER ) ; 
CREATE DOMAIN dom AS INTEGER ; 
CREATE VIEW x AS SELECT CAST ( x AS dom ) FROM x ; 
INSERT INTO x ( x ) VALUES ( NULL ) ; 
ALTER DOMAIN dom SET NOT NULL ; 
DROP DOMAIN ddef1 RESTRICT ; 
DROP DOMAIN ddef2 RESTRICT ; 
DROP DOMAIN ddef3 RESTRICT ; 
DROP DOMAIN ddef4 RESTRICT ; 
DROP DOMAIN ddef5 RESTRICT ; 
CREATE DOMAIN vchar4 VARCHAR ( 1 ) ; 
DROP DOMAIN vchar4 CASCADE ; 
CREATE DOMAIN str_domain AS TEXT NOT NULL ; 
CREATE TABLE x ( x INT , x INT ) ; 
ALTER TABLE x ADD COLUMN x str_domain ; 
ALTER TABLE x ADD COLUMN x str_domain2 ; 
$EXECUTE s1 ( 1 ) ; 
$$$$$$CREATE TYPE ddtest1 AS ( f1 posint ) ; 
CREATE TABLE x ( x ddtest1 ) ; 
INSERT INTO x VALUES ( ROW ( 1 ) ) ; 
CREATE TABLE x ( x ddtest1 [ ] ) ; 
CREATE DOMAIN ddtest1d AS ddtest1 ; 
CREATE TABLE x ( x ddtest1d ) ; 
DROP DOMAIN ddtest1d ; 
CREATE DOMAIN ddtest1d AS ddtest1 [ ] ; 
CREATE TYPE rposint AS RANGE ( subtype = posint ) ; 
CREATE TABLE x ( x rposint ) ; 
DROP TYPE rposint ; 
CREATE TABLE x ( x posint2 ) ; 
DROP TYPE ddtest1 ; 
$$$$SELECT x ( 121.000000 ) ; 
SELECT x ( 1.234560 ) ; 
CREATE DOMAIN mynums AS NUMERIC ( 1 , 1 ) [ 1 ] ; 
$$$$CREATE DOMAIN mynums2 AS mynums ; 
$$$$DROP FUNCTION x ( NUMERIC ) ; 
$$$$CREATE DOMAIN di AS INT ; 
$$$$$$$$DROP DOMAIN di ; 
CREATE TABLE x ( x inotnull ) ; 
INSERT INTO x VALUES ( NULL ) ; 
DROP DOMAIN inotnull ; 
DROP FUNCTION x ( anyelement , anyelement ) ; 
CREATE DOMAIN testdomain1 AS INT ; 
ALTER DOMAIN testdomain1 RENAME TO testdomain2 ; 
ALTER DOMAIN testdomain1 RENAME CONSTRAINT unsigned TO unsigned_foo ; 
ALTER DOMAIN testdomain1 DROP CONSTRAINT unsigned_foo ; 
DROP DOMAIN testdomain1 ; 
INSERT INTO x VALUES ( x ) ; 
$$$$$$SELECT x ( * ) > 1 FROM x ; 
CREATE TABLE x ( x float8 ) ; 
SELECT 'x' AS five , * FROM x ; 
SELECT 'x' AS one , x . * FROM x f WHERE x . x = 'x' ; 
SELECT 'x' AS three , x . * FROM x f WHERE 'x' > x . x ; 
SELECT 'x' AS three , x . * FROM x f WHERE x . x < 'x' ; 
SELECT 'x' AS four , x . * FROM x f WHERE 'x' >= x . x ; 
SELECT 'x' AS four , x . * FROM x f WHERE x . x <= 'x' ; 
SELECT 'x' AS three , x . x , x . x * 'x' AS x FROM x f WHERE x . x > 'x' ; 
SELECT 'x' AS three , x . x , x . x + 'x' AS x FROM x f WHERE x . x > 'x' ; 
SELECT 'x' AS three , x . x , x . x / 'x' AS x FROM x f WHERE x . x > 'x' ; 
SELECT 'x' AS three , x . x , x . x - 'x' AS x FROM x f WHERE x . x > 'x' ; 
SELECT 'x' AS one , x . x ^ 'x' AS square_f1 FROM x f WHERE x . x = 'x' ; 
@SELECT 'x' AS five , x . x , x . x AS abs_f1 FROM x f ; 
SELECT 'x' AS five , x . x , x ( x . x ) AS trunc_f1 FROM x f ; 
SELECT 'x' AS five , x . x , x ( x . x ) AS round_f1 FROM x f ; 
SELECT x ( x ) AS ceil_f1 FROM x f ; 
SELECT x ( x ) AS ceiling_f1 FROM x f ; 
SELECT x ( x ) AS floor_f1 FROM x f ; 
SELECT x ( x ) AS sign_f1 FROM x f ; 
SET extra_float_digits = 1 ; 
SELECT x ( x 'x' ) AS eight ; 
SELECT x ( x 'x' , x 'x' ) ; 
SELECT 'x' AS three , x . x , x ( x ( x . x ) ) AS exp_ln_f1 FROM x f WHERE x . x > 'x' ; 
UPDATE x SET x = x . x * 'x' WHERE x . x > 'x' ; 
SELECT 'x' AS bad , x . x * 'x' FROM x f ; 
SELECT 'x' AS bad , x . x ^ 'x' FROM x f ; 
SELECT 1 ^ 1 + 1 ^ 1 + 1 ^ 0.000000 + 1 ^ 0.500000 ; 
SELECT 'x' AS bad , x ( x . x ) FROM x f WHERE x . x = 'x' ; 
SELECT 'x' AS bad , x ( x . x ) FROM x f WHERE x . x < 'x' ; 
SELECT 'x' AS bad , x ( x . x ) FROM x f ; 
SELECT 'x' AS bad , x . x / 'x' FROM x f ; 
RESET extra_float_digits ; 
DELETE FROM x ; 
CREATE TYPE xfloat8 ; 
CREATE FUNCTION x ( cstring ) RETURNS xfloat8 IMMUTABLE STRICT LANGUAGE internal AS 'x' ; 
CREATE FUNCTION x ( xfloat8 ) RETURNS cstring IMMUTABLE STRICT LANGUAGE internal AS 'x' ; 
CREATE CAST ( xfloat8 AS float8 ) WITHOUT FUNCTION ; 
CREATE CAST ( float8 AS xfloat8 ) WITHOUT FUNCTION ; 
CREATE CAST ( xfloat8 AS BIGINT ) WITHOUT FUNCTION ; 
CREATE CAST ( BIGINT AS xfloat8 ) WITHOUT FUNCTION ; 
DROP TYPE xfloat8 CASCADE ; 
INSERT INTO x VALUES ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) , ( 1 , 'x' , 1 ) ; 
REFRESH MATERIALIZED VIEW x ; 
CREATE MATERIALIZED VIEW x AS SELECT x ( x ) AS grandtot FROM x ; 
CREATE UNIQUE INDEX x ON x ( ( x > 1 ) ) ; 
CREATE UNIQUE INDEX x ON x ( x ) WHERE x < 1 ; 
CREATE VIEW x AS SELECT x ( x ) AS grandtot FROM x ; 
EXPLAIN ( costs off ) CREATE MATERIALIZED VIEW x AS SELECT * FROM x ; 
CREATE MATERIALIZED VIEW x AS SELECT * FROM x ; 
ALTER MATERIALIZED VIEW x SET SCHEMA mvtest_mvschema ; 
SET search_path = mvtest_mvschema , public ; 
INSERT INTO x VALUES ( 1 , 'x' , 1 ) ; 
REFRESH MATERIALIZED VIEW CONCURRENTLY x ; 
RESET search_path ; 
EXPLAIN ( costs off ) SELECT * FROM x ; 
DROP MATERIALIZED VIEW IF EXISTS x ; 
REFRESH MATERIALIZED VIEW CONCURRENTLY x WITH NO DATA ; 
SELECT * FROM x FOR SHARE ; 
CREATE VIEW x AS SELECT 1 moo ; 
CREATE VIEW x AS SELECT x , 1 * x FROM x UNION ALL SELECT x , 1 * x FROM x ; 
CREATE MATERIALIZED VIEW x AS SELECT x , 1 * x FROM x UNION ALL SELECT x , 1 * x FROM x ; 
CREATE MATERIALIZED VIEW x AS SELECT * FROM x WHERE x = 1 ; 
DROP VIEW x CASCADE ; 
CREATE TABLE x ( x , x ) AS VALUES ( 1 , 1 ) ; 
CREATE UNIQUE INDEX ON x ( x ) ; 
INSERT INTO x SELECT * FROM x ; 
CREATE TABLE x ( x , x , x ) AS VALUES ( 1 , 1 , 1 ) ; 
INSERT INTO x VALUES ( 1 , 1 , 1 ) ; 
CREATE MATERIALIZED VIEW x AS SELECT 1 AS col1 WITH NO DATA ; 
CREATE MATERIALIZED VIEW x AS SELECT * FROM x WHERE x = ( SELECT LEAST ( x ) FROM x ) WITH NO DATA ; 
DROP MATERIALIZED VIEW x CASCADE ; 
CREATE TABLE x ( x serial PRIMARY KEY , x box ) ; 
INSERT INTO x ( x ) VALUES ( 'x' ) , ( 'x' ) , ( 'x' ) ; 
CREATE UNIQUE INDEX x ON x ( x ) ; 
UPDATE x SET x = 'x' WHERE x = 1 ; 
SELECT * FROM x ORDER BY x ; 
UPDATE x SET x = 1 WHERE x = 1 ; 
DROP MATERIALIZED VIEW x ; 
CREATE TABLE x AS SELECT x ( 1 , 1 ) AS a ; 
CREATE MATERIALIZED VIEW x AS SELECT x FROM x WHERE x <= 1 ; 
DELETE FROM x WHERE EXISTS ( SELECT * FROM x WHERE x . x = x . x ) ; 
SET ROLE regress_user_mvtest ; 
CREATE MATERIALIZED VIEW IF NOT EXISTS x AS SELECT * FROM x ; 
DROP OWNED BY x CASCADE ; 
$$CREATE MATERIALIZED VIEW x AS SELECT 1 AS x WITH NO DATA ; 
$$SELECT x FROM x TABLESAMPLE x ( 1 ) REPEATABLE ( 1 ) ; 
SELECT x FROM x TABLESAMPLE x ( 5.500000 ) REPEATABLE ( 1 ) ; 
FETCH FIRST FROM tablesample_cur ; 
FETCH NEXT FROM tablesample_cur ; 
CLOSE tablesample_cur ; 
EXPLAIN ( COSTS OFF ) SELECT * FROM x ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x TABLESAMPLE x ( 1 ) ; 
SELECT x ( * ) FROM x TABLESAMPLE x ( 1 ) ; 
SELECT x ( * ) FROM x ; 
SELECT * FROM ( VALUES ( 1 ) , ( 1 ) ) v ( pct ) , LATERAL ( SELECT x ( * ) FROM x TABLESAMPLE x ( x ) ) ss ; 
EXPLAIN ( costs off ) SELECT x , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( pct ) , LATERAL ( SELECT * FROM x TABLESAMPLE x ( x ) ) ss GROUP BY x ; 
SELECT x , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( pct ) , LATERAL ( SELECT * FROM x TABLESAMPLE x ( x ) ) ss GROUP BY x ; 
SELECT x FROM x TABLESAMPLE x ( 1 ) ; 
WITH query_select AS ( SELECT * FROM x ) SELECT * FROM x TABLESAMPLE x ( 5.500000 ) REPEATABLE ( 1 ) ; 
CREATE TABLE x ( x INT ) PARTITION BY list ( a ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ; 
EXPLAIN ( costs off ) SELECT * FROM x TABLESAMPLE x ( 1 ) ; 
DROP TABLE x , x , x ; 
$$$$SELECT * INTO TABLE x FROM x ; 
SELECT * INTO TABLE x FROM x WHERE x < 1 ; 
INSERT INTO x VALUES ( 'x' , 'x' , 'x' ) , ( 'x' , 'x' , 'x' ) ; 
UPDATE x SET x = 'x' ; 
CREATE TABLE x ( x int4 , x float4 , x polygon ) ; 
SET DateStyle = 'x' ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' ; 
SET datestyle TO dmy ; 
RESET datestyle ; 
SELECT TIME WITHOUT TIME ZONE 'x' ; 
SELECT TIME WITH TIME ZONE 'x' ; 
SELECT x 'x' AS Confucius' Birthday" ; 
SELECT x 'x' AS Julian Epoch" ; 
SELECT x 'x' + TIME 'x' AS Date + Time" ; 
SELECT x 'x' + TIME WITH TIME ZONE 'x' AS Date + Time PST" ; 
SELECT x 'x' + TIME WITH TIME ZONE 'x' AS Date + Time UTC" ; 
SELECT x 'x' + INTERVAL 'x' AS Add Two Years" ; 
SELECT x 'x' - INTERVAL 'x' AS Subtract Two Years" ; 
SELECT x 'x' - TIME 'x' AS Subtract Time" ; 
SELECT x 'x' - TIME WITH TIME ZONE 'x' AS Subtract Time UTC" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' - INTERVAL 'x' AS Feb 29" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' - INTERVAL 'x' AS Feb 28" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' AS Dec 31" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' AS Feb 23, 285506" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' AS Jan 20, 288244" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' AS Dec 31, 294276" ; 
SELECT TIMESTAMP WITHOUT TIME ZONE 'x' - TIMESTAMP WITHOUT TIME ZONE 'x' AS 106751991 Days" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' = ( TIMESTAMP WITHOUT TIME ZONE 'x' + INTERVAL 'x' ) ) AS True" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' = ( TIMESTAMP WITHOUT TIME ZONE 'x' - INTERVAL 'x' ) ) AS True" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' > 'x' ) AS True" ; 
SELECT x 'x' + TIME 'x' AS Jan_01_1994_11am" ; 
SELECT x 'x' + TIME 'x' AS Jan_01_1994_10am" ; 
SELECT x 'x' + x 'x' AS Jan_01_1994_8am" ; 
SELECT x ( x 'x' , TIME WITH TIME ZONE 'x' ) AS Jan_01_1994_8am" ; 
SELECT 'x' AS 64" , x + INTERVAL 'x' AS one_year FROM x ; 
SELECT 'x' AS 64" , x - INTERVAL 'x' AS one_year FROM x ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' AS Feb 29" ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' AS Feb 28" ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' + INTERVAL 'x' AS Dec 31" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' = ( TIMESTAMP WITH TIME ZONE 'x' + INTERVAL 'x' ) ) AS True" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' = ( TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' ) ) AS True" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' > 'x' ) AS True" ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' + INTERVAL 'x' AS Apr 3, 12:00" ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' + INTERVAL 'x' AS Apr 3, 13:00" ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' AS Apr 2, 12:00" ; 
SELECT TIMESTAMP WITH TIME ZONE 'x' - INTERVAL 'x' AS Apr 2, 11:00" ; 
RESET TIME ZONE ; 
SELECT x ( x 'x' , TIME 'x' ) AS Jan_01_1994_10am" ; 
SELECT x ( x 'x' , TIME 'x' ) AS Jan_01_1994_9am" ; 
SELECT x ( x 'x' , TIME WITH TIME ZONE 'x' ) AS Jan_01_1994_11am" ; 
SELECT x ( x 'x' , TIME WITH TIME ZONE 'x' ) AS Jan_01_1994_10am" ; 
SELECT CAST ( TIME 'x' AS INTERVAL ) AS +01:02" ; 
SELECT CAST ( INTERVAL 'x' AS TIME ) AS 02:03:00" ; 
SELECT TIME 'x' + INTERVAL 'x' AS 03:31:00" ; 
SELECT TIME 'x' - INTERVAL 'x' AS 23:29:00" ; 
SELECT TIME 'x' + INTERVAL 'x' AS 14:31:00" ; 
SELECT TIME 'x' + INTERVAL 'x' AS 07:31:00" ; 
SELECT CAST ( TIME WITH TIME ZONE 'x' AS INTERVAL ) AS +00:01" ; 
SELECT CAST ( INTERVAL 'x' AS TIME WITH TIME ZONE ) AS 02:03:00-08" ; 
SELECT TIME WITH TIME ZONE 'x' - INTERVAL 'x' AS 23:29:00-08" ; 
SELECT TIME WITH TIME ZONE 'x' + INTERVAL 'x' AS 14:31:00-08" ; 
SELECT CAST ( CAST ( x 'x' + TIME WITH TIME ZONE 'x' + INTERVAL 'x' AS TIME WITH TIME ZONE ) AS TIME ) AS 07:31:00" ; 
SELECT CAST ( CAST ( x 'x' + TIME WITH TIME ZONE 'x' + INTERVAL 'x' AS TIMESTAMP WITHOUT TIME ZONE ) AS TIME ) AS 07:31:00" ; 
SELECT x . x AS t , x . x AS i , x . x + x . x AS add" , x . x - x . x AS subtract" FROM x t , x i WHERE x . x BETWEEN 'x' AND 'x' AND x . x BETWEEN 'x' AND 'x' ORDER BY 1 , 1 ; 
SELECT x . x AS t , x . x AS i , x . x + x . x AS add" , x . x - x . x AS subtract" FROM x t , x i ORDER BY 1 , 1 ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) AS True" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) AS False" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) AS True" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , TIMESTAMP WITH TIME ZONE 'x' ) AS False" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) AS True" ; 
SELECT ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITH TIME ZONE 'x' , INTERVAL 'x' ) AS False" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) AS True" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) AS False" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) AS True" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , TIMESTAMP WITHOUT TIME ZONE 'x' ) AS False" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) AS True" ; 
SELECT ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) OVERLAPS ( TIMESTAMP WITHOUT TIME ZONE 'x' , INTERVAL 'x' ) AS False" ; 
SELECT ( TIME 'x' , TIME 'x' ) OVERLAPS ( TIME 'x' , TIME 'x' ) AS True" ; 
SELECT ( TIME 'x' , INTERVAL 'x' ) OVERLAPS ( TIME 'x' , INTERVAL 'x' ) AS True" ; 
SELECT ( TIME 'x' , INTERVAL 'x' ) OVERLAPS ( TIME 'x' , INTERVAL 'x' ) AS False" ; 
CREATE TABLE x ( x TIMESTAMP WITH TIME ZONE ) ; 
INSERT INTO x ( x ) SELECT x FROM x WHERE x BETWEEN 'x' AND 'x' OR x BETWEEN 'x' AND 'x' ; 
SELECT 'x' AS 16" , x AS timestamp" FROM x ORDER BY x ; 
SELECT 'x' AS 160" , x . x AS timestamp" , x . x AS interval" , x . x + x . x AS plus FROM x d , x t ORDER BY x , x , x ; 
SELECT 'x' AS 160" , x . x AS timestamp" , x . x AS interval" , x . x - x . x AS minus FROM x d , x t WHERE x ( x . x ) ORDER BY x , x , x ; 
SELECT 'x' AS 16" , x . x AS timestamp" , TIMESTAMP WITH TIME ZONE 'x' AS gpstime_zero , x . x - TIMESTAMP WITH TIME ZONE 'x' AS difference FROM x d ORDER BY x ; 
SELECT 'x' AS 226" , x . x AS timestamp1 , x . x AS timestamp2 , x . x - x . x AS difference FROM x d1 , x d2 ORDER BY x , x , x ; 
SET DateStyle TO 'x' ; 
SHOW DateStyle ; 
SELECT 'x' AS 64" , x AS us_postgres FROM x ; 
SELECT 'x' AS 64" , x AS us_iso FROM x ; 
SELECT 'x' AS 64" , x AS us_sql FROM x ; 
SELECT x ( * ) AS one FROM x WHERE x = 'x' ; 
SELECT 'x' AS 65" , x AS european_postgres FROM x ; 
SELECT 'x' AS 65" , x AS european_iso FROM x ; 
SELECT 'x' AS 65" , x AS european_sql FROM x ; 
RESET DateStyle ; 
SELECT x ( 'x' , x 'x' ) ; 
SELECT x , x ( 'x' , 'x' || x ) FROM x ( 1 , 1 ) i ; 
SHOW TIME ZONE ; 
CREATE TEMP TABLE x ( x INT ) ; 
CREATE TEMP TABLE x ( x FLOAT ) ; 
INSERT INTO x VALUES ( 2.100000 ) ; 
\CREATE TEMP TABLE x ( x INT ) ON COMMIT DELETE ROWS ; 
CREATE INDEX ON x ( x ( 'x' ) ) ; 
CREATE TEMP TABLE x ( x ) ON COMMIT DELETE ROWS AS SELECT 1 ; 
CREATE TEMP TABLE x ( x INT ) ON COMMIT DROP ; 
CREATE TEMP TABLE x ( x ) ON COMMIT DROP AS SELECT 1 ; 
CREATE TABLE x ( x INT ) ON COMMIT DELETE ROWS ; 
CREATE TABLE x ( x ) ON COMMIT DELETE ROWS AS SELECT 1 ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY ) ; 
CREATE TEMP TABLE x ( x INT REFERENCES x ) ON COMMIT DELETE ROWS ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY ) ON COMMIT DELETE ROWS ; 
CREATE TEMP TABLE x ( x INT REFERENCES x ) ; 
CREATE TABLE x . whereami ( x TEXT ) ; 
INSERT INTO x . whereami VALUES ( 'x' ) ; 
$$$$SET search_path = pg_temp , public ; 
SET search_path = public , pg_temp ; 
SELECT pg_temp . whoami ( ) ; 
DROP TABLE x . whereami ; 
SELECT pg_temp . nonempty ( 'x' ) ; 
CREATE TEMP TABLE x ( x INT ) PARTITION BY list ( a ) ON COMMIT DELETE ROWS ; 
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ON COMMIT DELETE ROWS ; 
CREATE TEMP TABLE x ( x INT ) PARTITION BY list ( a ) ON COMMIT DROP ; 
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ON COMMIT DROP ; 
INSERT INTO x VALUES ( 1 ) , ( 1 ) ; 
~SELECT x FROM x WHERE x 'x' ; 
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ON COMMIT PRESERVE ROWS ; 
~SELECT x FROM x WHERE x 'x' ORDER BY x ; 
CREATE TEMP TABLE x ( ) INHERITS ( x ) ON COMMIT DELETE ROWS ; 
~CREATE TEMP TABLE x ( ) INHERITS ( x ) ON COMMIT DROP ; 
~$$PREPARE TRANSACTION 'x' ; 
$$DROP FUNCTION pg_temp . twophase_func ( ) ; 
@@CREATE TYPE pg_temp . twophase_type AS ( a INT ) ; 
CREATE VIEW x . twophase_view AS SELECT 1 ; 
CREATE SEQUENCE x . twophase_seq ; 
SELECT x FROM x ; 
LOCK x IN ACCESS EXCLUSIVE MODE ; 
\CREATE TABLE x ( x INT DEFAULT 1 , x INT , x TEXT ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x TEXT ) ; 
INSERT INTO x VALUES ( 1 , 1 , 'x' ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 1 ) ; 
UPDATE x SET x = DEFAULT , x = DEFAULT ; 
UPDATE x AS x SET x = 1 WHERE x . x = 1 ; 
UPDATE x x SET x = x . x + 1 WHERE x . x = 1 ; 
UPDATE x SET x = x . x FROM ( VALUES ( 1 , 1 ) ) AS v ( i , j ) WHERE x . x = x . x ; 
UPDATE x SET x = x . * FROM ( VALUES ( 1 , 1 ) ) AS v ( i , j ) WHERE x . x = x . x ; 
INSERT INTO x SELECT x , x + 1 , x FROM x ; 
UPDATE x SET ( x , x , x ) = ( 'x' , x + 1 , DEFAULT ) WHERE x = 'x' ; 
UPDATE x SET ( x , x ) = ( 'x' , x + x ) , x = x + 1 WHERE x = 1 ; 
UPDATE x SET ( x , x ) = ( SELECT x , x FROM x WHERE x = 1 AND x = 'x' ) WHERE x = 1 AND x = 1 ; 
UPDATE x x SET ( x , x ) = ( SELECT x + 1 , x FROM x i WHERE x . x = x . x AND x . x = x . x AND x . x IS NOT DISTINCT FROM x . x ) ; 
UPDATE x SET ( x , x ) = ( SELECT x + 1 , x FROM x ) ; 
UPDATE x SET ( x , x ) = ( SELECT x + 1 , x FROM x WHERE x = 1 ) WHERE x = 1 ; 
UPDATE x SET ( x , x ) = ROW ( x . * ) FROM ( VALUES ( 1 , 1 ) ) AS v ( i , j ) WHERE x . x = x . x ; 
UPDATE x SET ( x , x ) = ( x . * ) FROM ( VALUES ( 1 , 1 ) ) AS v ( i , j ) WHERE x . x = x . x ; 
UPDATE x AS x SET x = x . x + 1 WHERE x . x = 1 ; 
UPDATE x SET x = x ( 'x' , 1 ) WHERE x = 'x' ; 
SELECT x , x , x ( x ) FROM x ; 
UPDATE x x SET ( x , x ) = ( SELECT x , x FROM x s WHERE x . x = x . x ) WHERE CURRENT_USER = SESSION_USER ; 
INSERT INTO x VALUES ( 1 , 'x' ) ; 
WITH aaa AS ( SELECT 1 AS a , 'x' AS b ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET ( x , x ) = ( SELECT x , x FROM x ) RETURNING * ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET ( x , x ) = ( SELECT x || 'x' , x FROM x i WHERE x . x = x . x ) RETURNING * ; 
CREATE TABLE x ( x VARCHAR , x NUMERIC , x TEXT , x BIGINT , x INT ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES FROM ( 'x' , 1 ) TO ( 'x' , 1 ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 'x' , 1 ) TO ( 'x' , 1 ) ; 
UPDATE x SET x = x - 1 ; 
ALTER TABLE x DROP COLUMN x , DROP COLUMN x , DROP COLUMN x ; 
ALTER TABLE x ADD COLUMN x NUMERIC , ADD COLUMN x VARCHAR , ADD COLUMN x TEXT ; 
ALTER TABLE x DROP COLUMN x ; 
ALTER TABLE x ADD COLUMN x BIGINT ; 
CREATE TABLE x PARTITION OF x FOR VALUES FROM ( 1 ) TO ( 1 ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES FROM ( 1 ) TO ( 1 ) ; 
CREATE TABLE x ( x VARCHAR , x INT , x NUMERIC , x BIGINT , x TEXT ) ; 
\EXPLAIN ( costs off ) UPDATE x SET x = x - 1 WHERE x > 1 ; 
UPDATE x SET x = x - 1 , x = x WHERE x = 1 ; 
UPDATE x SET x = x - 1 WHERE x > 1 ; 
UPDATE x SET x = x ; 
UPDATE x SET x = x + 1 WHERE x = 1 ; 
UPDATE x SET x = x + 1 RETURNING x , x , x ; 
UPDATE x SET x = x - 1 WHERE x > 1 RETURNING * ; 
UPDATE x SET x = x - 1 WHERE x > 1 RETURNING x , x + x ; 
CREATE VIEW x AS SELECT * FROM x WHERE ( SELECT x > x FROM x ) WITH CHECK OPTION ; 
UPDATE x SET x = 'x' , x = 1 , x = 1 WHERE x = 1 ; 
UPDATE x SET x = 'x' , x = 1 WHERE x = 1 ; 
UPDATE x SET x = 1 WHERE x = 'x' AND x > 1 AND x > 1 RETURNING ( x ) , * ; 
$$CREATE TRIGGER x AFTER UPDATE ON x REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
UPDATE x SET x = ( CASE WHEN x = 1 THEN 1 ELSE x + 1 END ) WHERE x = 'x' AND x > 1 AND x >= 1 ; 
CREATE TRIGGER x AFTER DELETE ON x REFERENCING OLD TABLE AS old_table FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x AFTER INSERT ON x REFERENCING NEW TABLE AS new_table FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
UPDATE x SET x = x + 1 WHERE x = 'x' AND x > 1 AND x >= 1 ; 
DROP TRIGGER trans_deletetrig ON range_parted ; 
DROP TRIGGER trans_inserttrig ON range_parted ; 
$$CREATE TRIGGER x BEFORE UPDATE OR INSERT ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
DROP TRIGGER trans_updatetrig ON range_parted ; 
DROP TRIGGER trig_c1_100 ON part_c_1_100 ; 
DROP TRIGGER trig_d1_15 ON part_d_1_15 ; 
DROP TRIGGER trig_d15_20 ON part_d_15_20 ; 
ALTER TABLE x ENABLE ROW LEVEL SECURITY ; 
GRANT ALL ON x , x TO x ; 
CREATE POLICY seeall ON x AS PERMISSIVE FOR SELECT USING ( TRUE ) ; 
CREATE POLICY policy_range_parted ON x FOR UPDATE USING ( TRUE ) WITH CHECK ( x % 1 = 1 ) ; 
SET SESSION AUTHORIZATION regress_range_parted_user ; 
UPDATE x SET x = 'x' , x = 1 WHERE x = 'x' AND x = 1 ; 
$$CREATE TRIGGER x BEFORE INSERT ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
DROP TRIGGER trig_d_1_15 ON part_d_1_15 ; 
CREATE POLICY policy_range_parted_subplan ON x AS RESTRICTIVE FOR UPDATE USING ( TRUE ) WITH CHECK ( ( SELECT x . x <= x FROM x ) ) ; 
DROP POLICY policy_range_parted ON range_parted ; 
DROP POLICY policy_range_parted_subplan ON range_parted ; 
DROP POLICY policy_range_parted_wholerow ON range_parted ; 
REVOKE ALL ON x , x FROM x ; 
$$CREATE TRIGGER x AFTER DELETE ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x AFTER UPDATE ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
CREATE TRIGGER x AFTER INSERT ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
DROP TRIGGER parent_delete_trig ON range_parted ; 
DROP TRIGGER parent_update_trig ON range_parted ; 
DROP TRIGGER parent_insert_trig ON range_parted ; 
DROP TRIGGER c1_delete_trig ON part_c_1_100 ; 
DROP TRIGGER c1_update_trig ON part_c_1_100 ; 
DROP TRIGGER c1_insert_trig ON part_c_1_100 ; 
DROP TRIGGER d1_delete_trig ON part_d_1_15 ; 
DROP TRIGGER d1_update_trig ON part_d_1_15 ; 
DROP TRIGGER d1_insert_trig ON part_d_1_15 ; 
DROP TRIGGER d15_delete_trig ON part_d_15_20 ; 
DROP TRIGGER d15_update_trig ON part_d_15_20 ; 
DROP TRIGGER d15_insert_trig ON part_d_15_20 ; 
CREATE TABLE x PARTITION OF x DEFAULT ; 
INSERT INTO x VALUES ( 'x' , 1 ) ; 
UPDATE x SET x = 'x' WHERE x = 'x' ; 
CREATE TABLE x ( x TEXT , x INT ) PARTITION BY list ( a ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' , 'x' ) ; 
CREATE TABLE x ( x NUMERIC , x INT , x int8 ) PARTITION BY list ( a ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) PARTITION BY list ( b ) ; 
CREATE TABLE x ( x INT , x int8 , x NUMERIC ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES IN ( 1 ) ; 
CREATE TABLE x ( x NUMERIC , x INT , x int8 ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES IN ( 1 , 1 ) ; 
UPDATE x SET x = x + x WHERE x = 1 ; 
$$DROP TRIGGER parted_mod_b ON sub_part1 ; 
$$CREATE TRIGGER x BEFORE DELETE ON x FOR EACH ROW EXECUTE PROCEDURE x ( ) ; 
DROP TRIGGER trig_skip_delete ON sub_part2 ; 
INSERT INTO x VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ; 
UPDATE x x SET x = 1 FROM x t2 WHERE x . x = x . x AND x = 1 ; 
$$CREATE TABLE x ( x INT , x INT ) PARTITION BY hash ( a custom_opclass , b custom_opclass ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES WITH ( modulus 1 , remainder 1 ) ; 
UPDATE x SET x = 1 , x = 1 WHERE x = 1 ; 
UPDATE x SET x = x - 1 WHERE x = 1 ; 
DROP OPERATOR CLASS custom_opclass USING hash ; 
DROP FUNCTION x ( a int4 , seed int8 ) ; 
EXPLAIN ( costs off ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO NOTHING ; 
CREATE UNIQUE INDEX x ON x ( x ( x ) COLLATE C" , x ( x ) text_pattern_ops ) ; 
EXPLAIN ( costs off ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ( x ) text_pattern_ops , x ( x ) COLLATE C" ) DO NOTHING ; 
EXPLAIN ( costs off ) INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ( x ) COLLATE C" , x ( x ) text_pattern_ops ) DO NOTHING ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT DO UPDATE SET x = x . x ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ( x ) ) DO UPDATE SET x = x . x ; 
CREATE UNIQUE INDEX x ON x ( x ( x ) ) ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ( x ) , x ( x ) ) DO UPDATE SET x = x . x ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) WHERE x LIKE 'x' DO UPDATE SET x = x . x ; 
CREATE TABLE x ( x BIGINT , x BIGINT ) ; 
CREATE UNIQUE INDEX x ON x ( COALESCE ( x , 1 ) ) ; 
CREATE UNIQUE INDEX x ON x ( x ) WHERE COALESCE ( x , 1 ) > 1 ; 
INSERT INTO x VALUES ( 1 , 1 ) ON CONFLICT ( COALESCE ( x , 1 ) ) DO NOTHING ; 
INSERT INTO x VALUES ( 1 , 1 ) ON CONFLICT ( x ) WHERE COALESCE ( x , 1 ) > 1 DO NOTHING ; 
CREATE VIEW x AS SELECT * FROM x WITH CASCADED CHECK OPTION ; 
CREATE TABLE x ( x CHAR ( 1 ) ) INHERITS ( x ) ; 
INSERT INTO x VALUES ( 'x' , 1 , 1 ) ; 
ALTER TABLE x DROP COLUMN x , DROP COLUMN x ; 
CREATE TABLE x ( x INT UNIQUE , x box , EXCLUDE USING gist ( x WITH && ) ) ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT ) ; 
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED ; 
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) ON CONFLICT DO NOTHING ; 
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE ; 
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) ON CONFLICT ( x ) DO UPDATE SET x = 1 ; 
CREATE TABLE x ( x INT UNIQUE , x CHAR ) PARTITION BY list ( a ) ; 
CREATE TABLE x PARTITION OF x ( x UNIQUE ) FOR VALUES IN ( 1 , 1 ) ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT DO NOTHING ; 
INSERT INTO x VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO NOTHING ; 
CREATE TABLE x ( x CHAR , x INT UNIQUE ) ; 
TRUNCATE x ; 
ALTER TABLE x DROP x , ADD x CHAR ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x WHERE x . x = 'x' ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 ) PARTITION BY list ( a ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) , ( 1 , 'x' ) , ( 1 , 'x' ) ON CONFLICT ( x ) DO UPDATE SET x = x . x WHERE x . x = 'x' ; 
CREATE UNIQUE INDEX ON ONLY x ( x ) ; 
ALTER INDEX x ATTACH PARTITION x ; 
CREATE TABLE x ( x TEXT , x INT , x INT , x TEXT ) ; 
CREATE UNIQUE INDEX ON x ( x , x ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 1 ) ON CONFLICT ( x , x ) DO UPDATE SET ( x , x , x ) = ROW ( x . * ) WHERE x = ( 1 , TEXT 'x' , 1 ) AND x = ( 1 , TEXT 'x' , 1 ) ; 
$$CREATE TRIGGER x AFTER UPDATE ON x REFERENCING NEW TABLE AS inserted FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 1 ) ON CONFLICT ( x , x ) DO UPDATE SET x = x . x + 1 ; 
##@#@#@#########$$$$SELECT FALSE <= 1 BETWEEN 1 AND 1 ; 
SELECT FALSE >= 1 BETWEEN 1 AND 1 ; 
BEGIN TRANSACTION ; 
GRANT USAGE ON SCHEMA schema_op1 TO x ; 
REVOKE USAGE ON SCHEMA schema_op1 FROM x ; 
SET ROLE regress_rol_op1 ; 
######$$$$#@##@##@#CREATE OPERATOR % ( leftarg = int8 ) ; 
CREATE TYPE type_op3 AS ENUM ( 'x' , 'x' , 'x' ) ; 
$$$$REVOKE USAGE ON TYPE type_op3 FROM x ; 
##CREATE TYPE type_op4 AS ENUM ( 'x' , 'x' , 'x' ) ; 
$$$$REVOKE USAGE ON TYPE type_op4 FROM x ; 
##CREATE TYPE type_op5 AS ENUM ( 'x' , 'x' , 'x' ) ; 
$$$$##CREATE TYPE type_op6 AS ENUM ( 'x' , 'x' , 'x' ) ; 
$$$$REVOKE USAGE ON TYPE type_op6 FROM x ; 
##CREATE SCHEMA x CREATE UNIQUE INDEX x ON x ( x ) CREATE VIEW x AS SELECT x + 1 AS a , x + 1 AS b FROM x CREATE TABLE x ( x serial , x INT UNIQUE ) ; 
SELECT x ( * ) FROM x WHERE x = ( SELECT x FROM x WHERE x = 'x' ) ; 
INSERT INTO x . abc DEFAULT VALUES ; 
SELECT * FROM x . abc ; 
SELECT * FROM x . abc_view ; 
ALTER SCHEMA x RENAME TO x ; 
DROP SCHEMA test_ns_schema_renamed CASCADE ; 
CREATE TABLE x ( x int4 ) ; 
COMMENT ON TABLE attmp_wrong IS 'x' ; 
COMMENT ON TABLE attmp IS 'x' ; 
COMMENT ON TABLE attmp IS NULL ; 
ALTER TABLE x ADD COLUMN x float8 ; 
ALTER TABLE x ADD COLUMN x float4 ; 
ALTER TABLE x ADD COLUMN x int2 ; 
ALTER TABLE x ADD COLUMN x polygon ; 
ALTER TABLE x ADD COLUMN x CHAR ; 
ALTER TABLE x ADD COLUMN x int4 ; 
ALTER TABLE x ADD COLUMN x tid ; 
ALTER TABLE x ADD COLUMN x xid ; 
ALTER TABLE x ADD COLUMN x oidvector ; 
ALTER TABLE x ADD COLUMN x BOOLEAN ; 
ALTER TABLE x ADD COLUMN x point ; 
ALTER TABLE x ADD COLUMN x lseg ; 
ALTER TABLE x ADD COLUMN x path ; 
ALTER TABLE x ADD COLUMN x box ; 
ALTER TABLE x ADD COLUMN x TIMESTAMP ; 
ALTER TABLE x ADD COLUMN x INTERVAL ; 
ALTER TABLE x ADD COLUMN x float8 [ ] ; 
ALTER TABLE x ADD COLUMN x float4 [ ] ; 
ALTER TABLE x ADD COLUMN x int2 [ ] ; 
INSERT INTO x ( x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x ) VALUES ( 1 , 'x' , 'x' , 4.100000 , 4.100000 , 1 , 'x' , 'x' , 1 , 'x' , 'x' , 'x' , TRUE , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
CREATE INDEX x ON x ( x , ( x + x ) , x ) ; 
ALTER INDEX x ALTER COLUMN 1 SET STATISTICS 1 ; 
ALTER TABLE x RENAME TO x ; 
ALTER INDEX x RENAME TO x ; 
SET ROLE regress_alter_table_user1 ; 
______ALTER INDEX IF EXISTS x RENAME TO x ; 
__CREATE VIEW x ( x ) AS SELECT x FROM x ; 
SET enable_seqscan TO off ; 
SET enable_bitmapscan TO off ; 
SELECT x FROM x WHERE x < 1 ; 
RESET enable_seqscan ; 
RESET enable_bitmapscan ; 
ALTER TABLE x ADD CONSTRAINT onek_unique1_constraint UNIQUE ( x ) ; 
ALTER TABLE x DROP CONSTRAINT onek_unique1_constraint_foo ; 
ALTER TABLE x ADD CONSTRAINT onek_check_constraint CHECK ( x >= 1 ) ; 
ALTER TABLE x RENAME CONSTRAINT onek_check_constraint TO onek_check_constraint_foo ; 
ALTER TABLE x DROP CONSTRAINT onek_check_constraint_foo ; 
CREATE TABLE x ( x INT CONSTRAINT con1 CHECK ( x > 1 ) , x INT , x INT ) ; 
CREATE TABLE x ( x INT CONSTRAINT con1 CHECK ( x > 1 ) , x INT ) INHERITS ( x ) ; 
CREATE TABLE x ( x INT , CONSTRAINT chk_a CHECK ( x > 1 ) , PRIMARY KEY ( x ) ) ; 
ALTER TABLE x RENAME CONSTRAINT chk_a TO chk_a_new ; 
ALTER TABLE x RENAME CONSTRAINT constraint_rename_cache_pkey TO constraint_rename_pkey_new ; 
CREATE TABLE x ( LIKE x INCLUDING ALL ) ; 
CREATE TABLE x ( x INT PRIMARY KEY ) ; 
CREATE TABLE x ( x INT , x INT , UNIQUE ( x , x ) ) ; 
ALTER TABLE x ADD CONSTRAINT attmpconstr FOREIGN KEY ( x ) REFERENCES x MATCH FULL ; 
ALTER TABLE x ADD CONSTRAINT attmpconstr FOREIGN KEY ( x ) REFERENCES x ( x ) MATCH FULL ; 
DELETE FROM x WHERE x = 1 ; 
ALTER TABLE x DROP CONSTRAINT attmpconstr ; 
ALTER TABLE x ADD CONSTRAINT attmpconstr FOREIGN KEY ( x ) REFERENCES x MATCH FULL NOT VALID ; 
ALTER TABLE x VALIDATE CONSTRAINT attmpconstr ; 
CREATE TABLE x ( ) INHERITS ( x ) ; 
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) ; 
ALTER TABLE x ADD CONSTRAINT b_le_20 CHECK ( x <= 1 ) NOT VALID ; 
ALTER TABLE x ADD CONSTRAINT check_a_is_2 CHECK ( x = 1 ) NO INHERIT NOT VALID ; 
ALTER TABLE x VALIDATE CONSTRAINT check_a_is_2 ; 
DELETE FROM ONLY x ; 
SET constraint_exclusion TO 'x' ; 
CREATE TABLE x ( x date , CHECK ( FALSE ) NO INHERIT NOT VALID ) ; 
EXPLAIN ( costs off ) SELECT * FROM x WHERE x BETWEEN 'x' AND 'x' ; 
ALTER TABLE x VALIDATE CONSTRAINT nv_child_2011_d_check ; 
CREATE TEMP TABLE x ( x inet ) ; 
ALTER TABLE x ADD FOREIGN KEY ( x ) REFERENCES x ; 
ALTER TABLE x ADD FOREIGN KEY ( x ) REFERENCES x ( x ) ; 
CREATE TEMP TABLE x ( x int8 ) ; 
CREATE TEMP TABLE x ( x NUMERIC ) ; 
CREATE TEMP TABLE x ( x NUMERIC PRIMARY KEY ) ; 
CREATE TEMP TABLE x ( x INT , x inet , PRIMARY KEY ( x , x ) ) ; 
CREATE TEMP TABLE x ( x cidr , x TIMESTAMP ) ; 
ALTER TABLE x ADD FOREIGN KEY ( x , x ) REFERENCES x ; 
ALTER TABLE x ADD FOREIGN KEY ( x , x ) REFERENCES x ( x , x ) ; 
CREATE TEMP TABLE x ( x INT , x inet ) ; 
ALTER TABLE x ADD CONSTRAINT fknd FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE ; 
ALTER TABLE x ADD CONSTRAINT fkdd FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED ; 
ALTER TABLE x ADD CONSTRAINT fkdi FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY IMMEDIATE ; 
ALTER TABLE x ADD CONSTRAINT fknd2 FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED ; 
ALTER TABLE x ALTER CONSTRAINT fknd2 NOT DEFERRABLE ; 
ALTER TABLE x ADD CONSTRAINT fkdd2 FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE ; 
ALTER TABLE x ALTER CONSTRAINT fkdd2 DEFERRABLE INITIALLY DEFERRED ; 
ALTER TABLE x ADD CONSTRAINT fkdi2 FOREIGN KEY ( x ) REFERENCES x ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE ; 
ALTER TABLE x ALTER CONSTRAINT fkdi2 DEFERRABLE INITIALLY IMMEDIATE ; 
ALTER TABLE x ADD CONSTRAINT atacc_test1 CHECK ( x > 1 ) ; 
CREATE TABLE x ( x INT , x INT , x INT ) ; 
ALTER TABLE x ADD CONSTRAINT atacc_test1 CHECK ( x + x < x * 1 ) ; 
INSERT INTO x ( x , x , x ) VALUES ( 1 , 1 , 1 ) ; 
CREATE TABLE x ( x INT CHECK ( x > 1 ) , x INT ) ; 
ALTER TABLE x ADD CHECK ( x > x ) ; 
CREATE TABLE x ( x INT ) INHERITS ( x , x ) ; 
ALTER TABLE x ADD CONSTRAINT foo CHECK ( x > 1 ) ; 
ALTER TABLE x NO INHERIT x ; 
ALTER TABLE x INHERIT x ; 
ALTER TABLE x RENAME x TO x ; 
ALTER TABLE x ADD x bool ; 
ALTER TABLE x DROP x ; 
ALTER TABLE x ADD x INT ; 
UPDATE x SET x = 1 WHERE x IS NULL ; 
CREATE TABLE x ( x INT ) INHERITS ( x ) ; 
ALTER TABLE x ADD CONSTRAINT foo CHECK ( x > 1 ) NO INHERIT ; 
ALTER TABLE x ADD CONSTRAINT atacc_test1 UNIQUE ( x ) ; 
ALTER TABLE x ALTER COLUMN x TYPE INTEGER USING 1 ; 
ALTER TABLE x ADD CONSTRAINT atacc_test1 UNIQUE ( x , x ) ; 
CREATE TABLE x ( x INT , x INT , UNIQUE ( x ) ) ; 
ALTER TABLE x ADD UNIQUE ( x ) ; 
CREATE TABLE x ( x serial , x INT ) ; 
ALTER TABLE x ADD CONSTRAINT atacc_test1 PRIMARY KEY ( x ) ; 
ALTER TABLE x ADD CONSTRAINT atacc_oid1 PRIMARY KEY ( x ) ; 
ALTER TABLE x DROP CONSTRAINT atacc_test1 RESTRICT ; 
ALTER TABLE x ADD COLUMN x INT PRIMARY KEY ; 
ALTER TABLE x ADD COLUMN x INT DEFAULT 1 PRIMARY KEY ; 
ALTER TABLE x ADD COLUMN x float8 NOT NULL DEFAULT x ( ) , ADD PRIMARY KEY ( x ) ; 
ALTER TABLE x ADD CONSTRAINT atacc_test1 PRIMARY KEY ( x , x ) ; 
ALTER TABLE x ADD CONSTRAINT atacc_test2 PRIMARY KEY ( x ) ; 
INSERT INTO x ( x , x ) VALUES ( NULL , 1 ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , NULL ) ; 
INSERT INTO x ( x , x ) VALUES ( NULL , NULL ) ; 
CREATE TABLE x ( x INT , x INT , PRIMARY KEY ( x ) ) ; 
ALTER TABLE x ALTER COLUMN x DROP NOT NULL ; 
ALTER TABLE x ALTER x SET NOT NULL ; 
ALTER TABLE x ALTER COLUMN x SET NOT NULL ; 
CREATE TABLE x ( x INT NOT NULL ) ; 
ALTER TABLE x ADD CONSTRAINT atacc1_pkey" PRIMARY KEY ( x ) ; 
ALTER TABLE x DROP CONSTRAINT atacc1_pkey" ; 
ALTER TABLE x ALTER x DROP NOT NULL ; 
INSERT INTO x VALUES ( NULL , 1 ) ; 
ALTER TABLE x ADD CONSTRAINT atacc1_constr_or CHECK ( x IS NOT NULL OR x < 1 ) ; 
ALTER TABLE x DROP CONSTRAINT atacc1_constr_or ; 
ALTER TABLE x ADD CONSTRAINT atacc1_constr_invalid CHECK ( x IS NOT NULL ) NOT VALID ; 
ALTER TABLE x DROP CONSTRAINT atacc1_constr_invalid ; 
ALTER TABLE x ADD CONSTRAINT atacc1_constr_a_valid CHECK ( x IS NOT NULL ) ; 
INSERT INTO x VALUES ( 1 , NULL ) ; 
ALTER TABLE x ALTER x SET NOT NULL , ALTER x SET NOT NULL ; 
ALTER TABLE x ALTER x DROP NOT NULL , ALTER x DROP NOT NULL ; 
ALTER TABLE x ADD CONSTRAINT atacc1_constr_b_valid CHECK ( x IS NOT NULL ) ; 
CREATE TABLE x ( x VARCHAR ( 1 ) ) INHERITS ( x ) ; 
INSERT INTO x ( x , x ) VALUES ( NULL , 'x' ) ; 
ALTER TABLE ONLY x ALTER x SET NOT NULL ; 
CREATE TABLE x ( x int4 DEFAULT 1 , x TEXT DEFAULT 'x' ) ; 
ALTER TABLE x ALTER COLUMN x DROP DEFAULT ; 
ALTER TABLE x ALTER COLUMN x SET DEFAULT 1 ; 
ALTER TABLE x ALTER COLUMN x SET DEFAULT 'x' ; 
DROP RULE def_view_test_ins ON def_view_test ; 
CREATE TABLE x ( x int4 NOT NULL , x int4 , x int4 NOT NULL , x int4 ) ; 
INSERT INTO x VALUES ( 1 , 1 , 1 , 1 ) ; 
SELECT * FROM x GROUP BY x ; 
SELECT x . * FROM x ; 
SELECT x . x FROM x ; 
SELECT x , x , x FROM x ; 
SELECT x , x , x , x FROM x ; 
INSERT INTO x VALUES ( DEFAULT , 1 , 1 , 1 ) ; 
INSERT INTO x ( x ) VALUES ( DEFAULT ) ; 
INSERT INTO x ( x , x , x , x ) VALUES ( 1 , 1 , 1 , 1 ) ; 
INSERT INTO x ( x , x , x , x ) VALUES ( DEFAULT , 1 , 1 , 1 ) ; 
ALTER TABLE x SET WITHOUT OIDS ; 
ANALYZE x ( a ) ; 
ANALYZE x ( ........pg.dropped.1........" ) ; 
VACUUM ANALYZE x ( a ) ; 
VACUUM ANALYZE x ( ........pg.dropped.1........" ) ; 
COMMENT ON COLUMN atacc1 . a IS 'x' ; 
COMMENT ON COLUMN atacc1 . ........pg.dropped.1........" IS 'x' ; 
ALTER TABLE x ALTER x SET STATISTICS 1 ; 
ALTER TABLE x ALTER x SET DEFAULT 1 ; 
ALTER TABLE x ALTER x DROP DEFAULT ; 
ALTER TABLE x ADD PRIMARY KEY ( x ) ; 
ALTER TABLE x ADD CHECK ( x > 1 ) ; 
CREATE TABLE x ( x int4 UNIQUE ) ; 
CREATE TABLE x AS SELECT * FROM x ; 
SELECT * INTO x FROM x ; 
CREATE TABLE x ( x float8 , x NUMERIC ( 1 , 1 ) , x TEXT COLLATE C" ) ; 
CREATE TABLE x ( x int4 , x int4 , x int4 ) ; 
COPY x TO STDOUT ; 
COPY x ( x ) TO STDOUT ; 
COPY x ( x , x ) FROM STDIN ; 
ALTER TABLE ONLY x DROP COLUMN x ; 
ALTER TABLE x RENAME COLUMN x TO x ; 
ALTER TABLE ONLY x RENAME COLUMN x TO x ; 
ALTER TABLE IF EXISTS x RENAME COLUMN x TO x ; 
ALTER TABLE x ADD COLUMN x INT ; 
ALTER TABLE ONLY x ADD COLUMN x INT ; 
CREATE TABLE x ( x INT NOT NULL ) INHERITS ( x ) ; 
CREATE TABLE x ( ) ; 
DROP TABLE x , x CASCADE ; 
ALTER TABLE x ADD x TEXT ; 
CREATE TABLE x ( x TEXT , x INT ) INHERITS ( x ) ; 
ALTER TABLE x ADD COLUMN x INT CHECK ( x > 1 ) ; 
UPDATE x SET x = x + 1 , x = x ( x ) ; 
CREATE DOMAIN mytype AS TEXT ; 
CREATE TEMP TABLE x ( x TEXT , x mytype , x TEXT ) ; 
INSERT INTO x VALUES ( 'x' , 'x' , 'x' ) ; 
DROP DOMAIN mytype CASCADE ; 
SELECT x , x ( x ) FROM x GROUP BY x ; 
CREATE TABLE x ( x serial8 , x BOOLEAN , CONSTRAINT anothertab_chk CHECK ( x <= 1 ) ) ; 
INSERT INTO x ( x , x ) VALUES ( DEFAULT , TRUE ) ; 
INSERT INTO x ( x , x ) VALUES ( DEFAULT , FALSE ) ; 
ALTER TABLE x ALTER COLUMN x TYPE TEXT USING CASE WHEN x IS TRUE THEN 'x' WHEN x IS FALSE THEN 'x' ELSE 'x' END ; 
CREATE TABLE x ( x INT PRIMARY KEY , x INT UNIQUE , x INT , x INT , x INT ) ; 
ALTER TABLE x ADD EXCLUDE USING btree ( x WITH = ) ; 
ALTER TABLE x ADD EXCLUDE USING btree ( x WITH = ) WHERE ( x IS NOT NULL ) ; 
ALTER TABLE x ADD EXCLUDE USING btree ( x WITH = ) WHERE ( x > 1 ) ; 
ALTER TABLE x ADD UNIQUE ( x , x ) ; 
ALTER TABLE x ALTER COLUMN x TYPE BIGINT ; 
ALTER TABLE x ALTER COLUMN x TYPE BIGINT , ALTER COLUMN x TYPE BIGINT , ALTER COLUMN x TYPE BIGINT ; 
ALTER TABLE x ALTER x TYPE TEXT USING x || 'x' , ALTER x TYPE BIGINT USING x * 1 ; 
CREATE TABLE x ( x INT , x tab1 ) ; 
CREATE TABLE x ( x TEXT , x INT ) ; 
CREATE INDEX ON x ( x ) ; 
COMMENT ON CONSTRAINT at_partitioned_id_name_key ON at_partitioned IS 'x' ; 
COMMENT ON INDEX at_partitioned_id_name_key IS 'x' ; 
COMMENT ON CONSTRAINT at_partitioned_0_id_name_key ON at_partitioned_0 IS 'x' ; 
COMMENT ON INDEX at_partitioned_0_id_name_key IS 'x' ; 
COMMENT ON CONSTRAINT at_partitioned_1_id_name_key ON at_partitioned_1 IS 'x' ; 
COMMENT ON INDEX at_partitioned_1_id_name_key IS 'x' ; 
CREATE TEMP TABLE x AS SELECT x , x AS oldoid , x AS oldfilenode FROM x WHERE x LIKE 'x' ; 
CREATE TABLE x ( x FLOAT CHECK ( x > 10.200000 ) , x FLOAT ) ; 
SELECT x , x , x , x , x FROM x c , x r WHERE x LIKE 'x' AND x . x = x . x ORDER BY 1 , 1 ; 
ALTER TABLE x ALTER COLUMN x TYPE NUMERIC ; 
ALTER TABLE x ADD CONSTRAINT bnoinherit CHECK ( x > 1 ) NO INHERIT ; 
ALTER TABLE x ADD CONSTRAINT blocal CHECK ( x < 1 ) ; 
ALTER TABLE x ADD CONSTRAINT bmerged CHECK ( x > 1 ) ; 
CREATE TABLE x ( x SMALLINT ) INHERITS ( x ) ; 
CREATE TABLE x ( x int2 , x int4 , x int8 ) ; 
CREATE TABLE x ( x int4 , x int8 , x int2 ) ; 
CREATE TABLE x ( x int8 , x int2 , x int4 ) ; 
ALTER TABLE x ALTER COLUMN x TYPE int4 USING ( x ( x ) ) ; 
CREATE TABLE x ( x INT REFERENCES x , x TEXT ) ; 
ALTER TABLE x DROP CONSTRAINT check_fk_presence_2_id_fkey ; 
CREATE VIEW x AS SELECT * FROM x bt ; 
CREATE VIEW x AS SELECT * , x ( x ) AS j FROM x v1 ; 
CREATE OR REPLACE VIEW x AS SELECT * , 1 + 1 AS more FROM x bt ; 
EXECUTE p_ddl ; 
$$$$$$$$$$$$$$$$$$$$$$$$$$DROP FUNCTION x ( regclass , TEXT ) ; 
DROP TYPE lockmodes ; 
CREATE TYPE lockmodes AS ENUM ( 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' , 'x' ) ; 
BEGIN ; ALTER TABLE x ALTER COLUMN x SET STATISTICS 1 ; 
SELECT * FROM x ORDER BY 1 ; 
BEGIN ; ALTER TABLE x CLUSTER ON alterlock_pkey ; 
BEGIN ; ALTER TABLE x SET WITHOUT CLUSTER ; 
BEGIN ; ALTER TABLE x SET ( fillfactor = 1 ) ; 
BEGIN ; ALTER TABLE x RESET ( fillfactor ) ; 
BEGIN ; ALTER TABLE x SET ( toast . autovacuum_enabled = off ) ; 
BEGIN ; ALTER TABLE x SET ( autovacuum_enabled = off ) ; 
BEGIN ; ALTER TABLE x ALTER COLUMN x SET ( n_distinct = 1 ) ; 
BEGIN ; ALTER TABLE x SET ( autovacuum_enabled = off , fillfactor = 1 ) ; 
BEGIN ; ALTER TABLE x ALTER COLUMN x SET DEFAULT 'x' ; 
CREATE TRIGGER x BEFORE DELETE OR UPDATE ON x FOR EACH ROW EXECUTE PROCEDURE x ( 1 , 1 ) ; 
ALTER TABLE x VALIDATE CONSTRAINT alterlock2nv ; 
ALTER TABLE x RESET ( autovacuum_enabled ) ; 
ALTER VIEW x RESET ( autovacuum_enabled ) ; 
ALTER VIEW x SET ( security_barrier = off ) ; 
ALTER VIEW x RESET ( security_barrier ) ; 
ALTER TABLE x SET ( security_barrier = off ) ; 
ALTER TABLE x RESET ( security_barrier ) ; 
SELECT x ( NULL ) ; 
ALTER FUNCTION x ( TEXT ) CALLED ON NULL INPUT ; 
ALTER FUNCTION x ( TEXT ) RETURNS NULL ON NULL INPUT ; 
CREATE TABLE x . t1 ( x serial PRIMARY KEY , x INT CHECK ( x > 1 ) ) ; 
CREATE VIEW x . v1 AS SELECT * FROM x . t1 ; 
CREATE TYPE alter1 . ctype AS ( f1 INT , f2 TEXT ) ; 
CREATE OPERATOR CLASS alter1 . ctype_hash_ops DEFAULT FOR TYPE alter1 . ctype USING hash AS OPERATOR 1 alter1 . = ( alter1 . ctype , alter1 . ctype ) ; 
CREATE CONVERSION alter1 . latin1_to_utf8 FOR 'x' TO 'x' FROM iso8859_1_to_utf8 ; 
CREATE TEXT SEARCH TEMPLATE alter1 . tmpl ( init = dsimple_init , lexize = dsimple_lexize ) ; 
INSERT INTO x . t1 ( x ) VALUES ( 1 ) ; 
ALTER TABLE x . v1 SET SCHEMA alter2 ; 
ALTER FUNCTION alter1 . plus1 ( INT ) SET SCHEMA alter2 ; 
ALTER DOMAIN alter1 . posint SET SCHEMA alter2 ; 
ALTER OPERATOR CLASS alter1 . ctype_hash_ops USING hash SET SCHEMA alter2 ; 
ALTER OPERATOR FAMILY alter1 . ctype_hash_ops USING hash SET SCHEMA alter2 ; 
ALTER OPERATOR alter1 . = ( alter1 . ctype , alter1 . ctype ) SET SCHEMA alter2 ; 
ALTER FUNCTION alter1 . same ( alter1 . ctype , alter1 . ctype ) SET SCHEMA alter2 ; 
ALTER CONVERSION alter1 . latin1_to_utf8 SET SCHEMA alter2 ; 
ALTER TEXT SEARCH PARSER alter1 . prs SET SCHEMA alter2 ; 
ALTER TEXT SEARCH CONFIGURATION alter1 . cfg SET SCHEMA alter2 ; 
ALTER TEXT SEARCH TEMPLATE alter1 . tmpl SET SCHEMA alter2 ; 
ALTER TEXT SEARCH DICTIONARY alter1 . dict SET SCHEMA alter2 ; 
DROP SCHEMA alter1 ; 
SELECT * FROM x . t1 ; 
SELECT * FROM x . v1 ; 
SELECT alter2 . plus1 ( 1 ) ; 
DROP SCHEMA alter2 CASCADE ; 
CREATE TYPE test_type AS ( a INT ) ; 
ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE INTEGER ; 
ALTER TYPE test_type DROP ATTRIBUTE b ; 
ALTER TYPE test_type DROP ATTRIBUTE a , ADD ATTRIBUTE d BOOLEAN ; 
ALTER TYPE test_type RENAME ATTRIBUTE a TO aa ; 
ALTER TYPE test_type RENAME ATTRIBUTE d TO dd ; 
DROP TYPE test_type ; 
CREATE TYPE test_type1 AS ( a INT , b TEXT ) ; 
CREATE TABLE x ( x INT , x test_type1 ) ; 
CREATE TABLE x OF test_type2 ; 
CREATE TYPE test_typex AS ( a INT , b TEXT ) ; 
CREATE TABLE x ( x INT , x test_typex CHECK ( ( x ) . a > 1 ) ) ; 
DROP TYPE test_typex ; 
CREATE TYPE test_type3 AS ( a INT ) ; 
ALTER TYPE test_type3 DROP ATTRIBUTE a , ADD ATTRIBUTE b INT ; 
CREATE TYPE test_type_empty AS ( ) ; 
DROP TYPE test_type_empty ; 
CREATE TYPE tt_t0 AS ( z inet , x INT , y NUMERIC ( 1 , 1 ) ) ; 
ALTER TYPE tt_t0 DROP ATTRIBUTE z ; 
ALTER TABLE x OF tt_t0 ; 
CREATE TYPE tt_t1 AS ( x INT , y NUMERIC ( 1 , 1 ) ) ; 
CREATE TABLE x ( x TEXT CHECK ( x IS NOT NULL ) ) ; 
ALTER TABLE ONLY x DROP CONSTRAINT test_drop_constr_parent_c_check" ; 
ALTER TABLE IF EXISTS x ADD COLUMN x INT ; 
ALTER TABLE IF EXISTS x ADD CONSTRAINT xxx PRIMARY KEY ( x ) ; 
ALTER TABLE IF EXISTS x ADD CHECK ( x BETWEEN 1 AND 1 ) ; 
ALTER TABLE IF EXISTS x ALTER COLUMN x SET DEFAULT 1 ; 
ALTER TABLE IF EXISTS x SET SCHEMA alter2 ; 
DROP TABLE x . tt8 ; 
DROP SCHEMA alter2 ; 
CREATE TABLE x ( x INT , x INT CHECK ( x > 1 ) , x INT , CONSTRAINT comment_test_pk PRIMARY KEY ( x ) ) ; 
COMMENT ON COLUMN comment_test . id IS 'x' ; 
COMMENT ON INDEX comment_test_index IS 'x' ; 
COMMENT ON CONSTRAINT comment_test_positive_col_check ON comment_test IS 'x' ; 
COMMENT ON CONSTRAINT comment_test_pk ON comment_test IS 'x' ; 
COMMENT ON INDEX comment_test_pk IS 'x' ; 
ALTER TABLE x ALTER COLUMN x SET DATA TYPE INT ; 
ALTER TABLE x ALTER COLUMN x SET DATA TYPE TEXT ; 
ALTER TABLE x ALTER COLUMN x SET DATA TYPE BIGINT ; 
CREATE TABLE x ( x TEXT CONSTRAINT comment_test_child_fk REFERENCES x ) ; 
COMMENT ON COLUMN comment_test_child . id IS 'x' ; 
COMMENT ON INDEX comment_test_child_fk IS 'x' ; 
COMMENT ON CONSTRAINT comment_test_child_fk ON comment_test_child IS 'x' ; 
SHOW allow_system_table_mods ; 
CREATE TABLE x . new_system_table ( ) ; 
CREATE TABLE x ( x serial PRIMARY KEY , x TEXT ) ; 
ALTER TABLE x SET SCHEMA pg_catalog ; 
ALTER TABLE x SET SCHEMA public ; 
INSERT INTO x ( x ) VALUES ( 'x' ) , ( 'x' ) ; 
UPDATE x SET x = - x ; 
DELETE FROM x WHERE x = 'x' ; 
ALTER TABLE x DROP CONSTRAINT new_system_table_pkey ; 
CREATE UNLOGGED TABLE x ( x SERIAL PRIMARY KEY , x TEXT ) ; 
~~CREATE TABLE x ( x SERIAL PRIMARY KEY , x TEXT ) ; 
~ALTER TABLE x SET UNLOGGED ; 
~ALTER TABLE x ADD COLUMN x INTEGER ; 
ALTER TABLE x ADD EXCLUDE USING gist ( x WITH && ) ; 
ALTER TABLE x ALTER COLUMN x TYPE CHAR ( 1 ) ; 
ALTER TABLE x ADD CONSTRAINT chk_a CHECK ( x > 1 ) NO INHERIT ; 
CREATE TABLE x ( LIKE x ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES IN ( 'x' ) ; 
CREATE TABLE x ( x INT NOT NULL , x CHAR ( 1 ) COLLATE C" , CONSTRAINT check_a CHECK ( x > 1 ) ) PARTITION BY LIST ( a ) ; 
ALTER TABLE x OWNER TO x ; 
SET SESSION AUTHORIZATION regress_test_me ; 
CREATE TEMP TABLE x ( x INT ) PARTITION BY LIST ( a ) ; 
CREATE TYPE mytype AS ( a INT ) ; 
CREATE TABLE x OF mytype ; 
DROP TYPE mytype CASCADE ; 
CREATE TABLE x ( LIKE x , x INT ) ; 
CREATE TABLE x ( x CHAR ( 1 ) , x INT NOT NULL ) ; 
ALTER TABLE x ALTER x TYPE CHAR ( 1 ) COLLATE POSIX" ; 
CREATE TABLE x ( x CHAR ( 1 ) COLLATE C" , x INT NOT NULL ) ; 
ALTER TABLE x ADD CONSTRAINT check_a CHECK ( x >= 1 ) ; 
CREATE TABLE x ( x INT NOT NULL , x CHAR ( 1 ) COLLATE C" , CONSTRAINT check_a CHECK ( x > 1 ) ) ; 
CREATE TABLE x ( LIKE x INCLUDING CONSTRAINTS ) ; 
ALTER TABLE x ATTACH PARTITION x DEFAULT ; 
CREATE TABLE x ( x INT , x CHAR ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x ( LIKE x , CONSTRAINT check_a CHECK ( x IN ( 1 ) ) ) ; 
ALTER TABLE x DETACH PARTITION x ; 
ALTER TABLE x ADD CONSTRAINT check_a CHECK ( x IN ( 1 , 1 ) ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 1 , 1 ) ; 
CREATE TABLE x ( x INT NOT NULL CHECK ( x = 1 ) , x INT NOT NULL CHECK ( x >= 1 AND x <= 1 ) ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES FROM ( 1 , 1 ) TO ( 1 , 1 ) ; 
CREATE TABLE x ( x INT NOT NULL CHECK ( x = 1 ) , x INT NOT NULL CHECK ( x >= 1 AND x < 1 ) ) ; 
CREATE TABLE x ( LIKE x ) PARTITION BY LIST ( b ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , 'x' ) ; 
DELETE FROM x WHERE x NOT IN ( 1 ) ; 
ALTER TABLE x ADD CONSTRAINT check_a CHECK ( x IS NOT NULL AND x = 1 ) ; 
ALTER TABLE x DROP CONSTRAINT check_a ; 
ALTER TABLE x ADD CONSTRAINT check_a CHECK ( x IN ( 1 ) ) , ALTER x SET NOT NULL ; 
CREATE TABLE x ( x INT , LIKE x , CONSTRAINT check_a CHECK ( x IS NOT NULL AND x = 1 ) ) ; 
CREATE TABLE x ( LIKE x , CONSTRAINT check_a CHECK ( x IS NOT NULL AND x = 1 ) ) PARTITION BY LIST ( b ) ; 
ALTER TABLE x DROP x , DROP x , DROP x ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES IN ( 'x' , NULL ) ; 
CREATE TABLE x PARTITION OF x DEFAULT PARTITION BY LIST ( a ) ; 
CREATE TABLE x ( x INT , x TEXT ) PARTITION BY LIST ( a ) ; 
CREATE TABLE x PARTITION OF x DEFAULT PARTITION BY LIST ( b ) ; 
CREATE TABLE x PARTITION OF x ( CONSTRAINT check_1 CHECK ( x IS NOT NULL AND x = 1 ) ) FOR VALUES IN ( 'x' ) ; 
CREATE TABLE x ( x INT , x INT ) PARTITION BY HASH ( a part_test_int4_ops ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES WITH ( MODULUS 1 , REMAINDER 1 ) ; 
ALTER TABLE x ATTACH PARTITION x FOR VALUES WITH ( MODULUS 1 , REMAINDER 1 ) ; 
CREATE TABLE x PARTITION OF x FOR VALUES IN ( 'x' , 'x' , 'x' ) ; 
ALTER TABLE x ALTER COLUMN x TYPE TEXT ; 
ALTER TABLE ONLY x ALTER x DROP NOT NULL ; 
ALTER TABLE ONLY x DROP CONSTRAINT check_b ; 
ALTER TABLE ONLY x ADD CONSTRAINT check_a CHECK ( x > 1 ) ; 
ALTER TABLE ONLY x DROP CONSTRAINT check_a ; 
ALTER TABLE x ALTER x SET NOT NULL , ADD CONSTRAINT check_a2 CHECK ( x > 1 ) ; 
ALTER TABLE x DROP CONSTRAINT check_a2 ; 
ALTER TABLE x ADD x INT NOT NULL ; 
ALTER TABLE x ADD CONSTRAINT parted_validate_test_chka CHECK ( x > 1 ) NOT VALID ; 
ALTER TABLE x VALIDATE CONSTRAINT parted_validate_test_chka ; 
ALTER TABLE x ALTER COLUMN x SET ( n_distinct = 1 , n_distinct_inherited = 1 ) ; 
ALTER TABLE x ALTER COLUMN x RESET ( n_distinct_inherited ) ; 
CREATE TEMP TABLE x ( x INT ) PARTITION BY list ( a ) ; 
$$CREATE TRIGGER x BEFORE INSERT ON x FOR EACH STATEMENT EXECUTE PROCEDURE x ( ) ; 
$$CREATE OPERATOR CLASS at_test_sql_partop FOR TYPE int4 USING btree AS OPERATOR 1 < ( int4 , int4 ) , OPERATOR 1 <= ( int4 , int4 ) , OPERATOR 1 = ( int4 , int4 ) , OPERATOR 1 >= ( int4 , int4 ) , OPERATOR 1 > ( int4 , int4 ) , FUNCTION 1 x ( int4 , int4 ) ; 
DROP OPERATOR CLASS at_test_sql_partop USING btree ; 
DROP FUNCTION at_test_sql_partop ; 
RESET max_stack_depth ; 
SELECT x ( x ( x ) , FALSE ) FROM ( SELECT x AS b , x * 1 AS c FROM x ( 1 , 1 ) x ) q ; 
SELECT x ( x ( x ) , TRUE ) FROM ( SELECT x AS b , x * 1 AS c FROM x ( 1 , 1 ) x ) q ; 
$$$$SELECT x ( x ( x ) , FALSE ) FROM ( SELECT x || x AS b , x AS c , ARRAY [ ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) , ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) ] AS z FROM x ( 1 , 1 ) x , x ( 1 , 1 ) y ) q ; 
SELECT x ( x ( x ) , FALSE ) FROM x ( 1 , 1 ) x ; 
$$$$SELECT x ( x ) FROM ( SELECT x || x AS b , x AS c , ARRAY [ ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) , ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) ] AS z FROM x ( 1 , 1 ) x , x ( 1 , 1 ) y ) q ; 
$$$$SELECT x ( x , TRUE ) FROM ( SELECT x || x AS b , x AS c , ARRAY [ ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) , ROW ( x . * , ARRAY [ 1 , 1 , 1 ] ) ] AS z FROM x ( 1 , 1 ) x , x ( 1 , 1 ) y ) q ; 
SELECT x ( ROW ( ( SELECT x ( x ) AS d FROM x ( 1 , 1 ) x ) ) , FALSE ) ; 
SELECT x ( TIMESTAMP 'x' ) ; 
SET LOCAL TIME ZONE 10.500000 ; 
SET LOCAL TIME ZONE 1 ; 
$$$$CREATE TEMP TABLE x ( x TEXT , x json ) ; 
INSERT INTO x VALUES ( 'x' , 'x' ) , ( 'x' , 'x' ) , ( 'x' , 'x' ) ; 
SELECT * FROM x ( 'x' ) q ; 
SELECT x ( 'x' , 'x' , 'x' ) IS NULL AS expect_false ; 
SELECT x ( 'x' , 'x' , 'x' ) IS NULL AS expect_true ; 
CREATE TYPE jpop AS ( a TEXT , b INT , c TIMESTAMP ) ; 
CREATE DOMAIN js_int_not_null AS INT NOT NULL ; 
CREATE TYPE j_unordered_pair AS ( x INT , y INT ) ; 
_CREATE TYPE jsrec AS ( i INT , ia int4 , ia1 INT [ ] , ia2 INT [ ] [ ] , ia3 INT [ ] [ ] [ ] , ia1d js_int_array_1d , ia2d js_int_array_2d , t TEXT , ta TEXT [ ] , c CHAR ( 1 ) , ca CHAR ( 1 ) [ ] , ts TIMESTAMP , js json , jsb jsonb , jsa json [ ] , rec jpop , reca jpop [ ] ) ; 
CREATE TYPE jsrec_i_not_null AS ( i js_int_not_null ) ; 
SELECT x ( ROW ( 1 , 1 ) , 'x' ) ; 
CREATE TYPE jpop2 AS ( a INT , b json , c INT , d INT ) ; 
SELECT x , x ( ROW ( x , 1 ) , 'x' ) FROM ( VALUES ( 1 ) , ( 1 ) ) v ( i ) ; 
CREATE TEMP TABLE x ( x json ) ; 
DROP TYPE jsrec ; 
DROP TYPE jsrec_i_not_null ; 
DROP DOMAIN js_int_not_null ; 
DROP DOMAIN js_int_array_1d ; 
DROP DOMAIN js_int_array_2d ; 
DROP DOMAIN j_ordered_pair ; 
DROP TYPE j_unordered_pair ; 
SELECT x ( 'x' , 1 , 'x' , 1.200000 , 'x' , TRUE , 'x' , NULL , 'x' , x 'x' ) ; 
SELECT x ( 1 , 1 ) ; 
SELECT x ( NULL , 1 ) ; 
SELECT x ( x , 1 ) FROM ( SELECT 1 AS a , 1 AS b ) r ; 
SELECT x ( x 'x' , 1 ) ; 
INSERT INTO x VALUES ( 1 , 'x' , 'x' ) ; 
INSERT INTO x VALUES ( 1 , NULL , 'x' ) ; 
SELECT * FROM x ( 'x' ) AS x ( a INT , b TEXT , d TEXT ) ; 
SELECT * FROM x ( 'x' ) AS x ( a INT , b TEXT , c BOOLEAN ) ; 
SELECT * FROM x ( 'x' ) AS x ( a INT , b json , c BOOLEAN ) ; 
_SELECT * FROM x ( 'x' ) AS x ( ia int4 ) ; 
_____SELECT * FROM x ( 'x' ) AS x ( ia2 INT [ ] [ ] ) ; 
SELECT * FROM x ( 'x' ) AS x ( ia2 int4 [ ] [ ] ) ; 
CREATE TABLE x ( x INT , x macaddr8 ) ; 
CREATE INDEX x ON x USING btree ( x ) ; 
CREATE INDEX x ON x USING hash ( x ) ; 
SELECT x , x , x ( x ) FROM x ORDER BY 1 , 1 ; 
SELECT x & 'x' FROM x ; 
SELECT x | 'x' FROM x ; 
GRANT ALL ON SCHEMA temp_func_test TO x ; 
SET search_path TO temp_func_test , public ; 
CREATE FUNCTION x ( TEXT , date ) RETURNS bool LANGUAGE 'x' AS 'x' ; 
CREATE FUNCTION x ( TEXT [ ] ) RETURNS INT LANGUAGE 'x' AS 'x' ; 
CREATE FUNCTION x ( ) RETURNS bool LANGUAGE 'x' AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' IMMUTABLE AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' STABLE AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' VOLATILE AS 'x' ; 
ALTER FUNCTION x ( INT ) VOLATILE ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' SECURITY DEFINER AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' SECURITY INVOKER AS 'x' ; 
ALTER FUNCTION x ( INT ) SECURITY DEFINER ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' LEAKPROOF AS 'x' ; 
ALTER FUNCTION x ( INT ) LEAKPROOF ; 
ALTER FUNCTION x ( INT ) OWNER TO x ; 
SET SESSION AUTHORIZATION regress_unpriv_user ; 
ALTER FUNCTION x ( INT ) NOT LEAKPROOF ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' CALLED ON NULL INPUT AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' RETURNS NULL ON NULL INPUT AS 'x' ; 
CREATE FUNCTION x ( INT ) RETURNS bool LANGUAGE 'x' STRICT AS 'x' ; 
ALTER FUNCTION x ( INT ) CALLED ON NULL INPUT ; 
DROP FUNCTION x ( INT , INT , TEXT ) , x ( INT ) , x ( INT ) ; 
CREATE FUNCTION x ( BIGINT ) RETURNS bool LANGUAGE 'x' IMMUTABLE AS 'x' ; 
DROP FUNCTION functest_b_1 ; 
DROP FUNCTION x ( a INT ) ; 
SELECT * FROM x ( 1 ) ; 
DROP SCHEMA temp_func_test CASCADE ; 
SELECT x ( x ) AS avg_1 FROM x ; 
SELECT x ( x ) AS avg_32 FROM x WHERE x < 1 ; 
SELECT x ( x ) AS avg_3_4 FROM ONLY x ; 
SELECT x ( x ) AS sum_1500 FROM x ; 
SELECT x ( x ) AS sum_198 FROM x ; 
SELECT x ( x ) AS avg_431_773 FROM x ; 
SELECT x ( x ) AS avg_6_8 FROM ONLY x ; 
SELECT x ( x ) AS max_3 FROM x ; 
SELECT x ( x ) AS max_100 FROM x ; 
SELECT x ( x . x ) AS max_324_78 FROM x ; 
SELECT x ( x . x ) AS max_3_7 FROM x ; 
SELECT x ( 1.000000 ) , x ( 2.000000 ) ; 
SELECT x ( x , x ) FROM x ; 
SELECT x ( x , x ) , x ( x , x ) FROM x ; 
CREATE TABLE x ( x float8 , x float8 ) ; 
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ; 
SELECT x ( * ) , x ( x ) , x ( x , x ) , x ( x ) , x ( x , x ) , x ( x , x ) FROM x WHERE x IN ( 1 , 1 , 1 , 1 ) ; 
SELECT x ( * ) , x ( x ) , x ( x , x ) , x ( x ) , x ( x , x ) , x ( x , x ) FROM x ; 
SELECT x ( * ) , x ( x ) , x ( x , x ) , x ( x ) , x ( x , x ) , x ( x , x ) FROM x WHERE x IN ( 1 , 1 , 1 ) ; 
SELECT x ( * ) , x ( x ) , x ( x , x ) , x ( x ) , x ( x , x ) , x ( x , x ) FROM x WHERE x IN ( 1 , 1 ) ; 
SELECT x ( x ) AS cnt_1000 FROM x ; 
SELECT x ( DISTINCT x ) AS cnt_4 FROM x ; 
SELECT x ( * ) AS cnt_1000 FROM x ; 
SELECT ( SELECT x ( ( SELECT x . x FROM x i WHERE x . x = x . x ) ) ) FROM x o ; 
SELECT ARRAY ( SELECT x ( x + x ) s FROM x ( 1 , 1 ) y GROUP BY x ORDER BY x ) FROM x ( 1 , 1 ) x ; 
CREATE TEMPORARY TABLE x ( x INT2 , x INT4 , x INT8 , x INTEGER , x INT2 , x BIT ( 1 ) ) ; 
SELECT x ( x ) AS ?" , x ( x ) AS ?" FROM x ; 
COPY x FROM STDIN NULL 'x' ; 
CREATE TEMPORARY TABLE x ( x BOOL , x BOOL , x BOOL , x BOOL ) ; 
SELECT x ( x ) AS n" , x ( x ) AS n" FROM x ; 
SELECT x ( x ) AS f" , x ( x ) AS t" , x ( x ) AS f" , x ( x ) AS n" , x ( NOT x ) AS f" , x ( NOT x ) AS t" FROM x ; 
SELECT x ( x ) AS t" , x ( x ) AS t" , x ( x ) AS f" , x ( x ) AS n" , x ( NOT x ) AS f" , x ( NOT x ) AS t" FROM x ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x WHERE x < 1 ; 
SELECT x ( x ) FROM x WHERE x < 1 ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x WHERE x > 1 ; 
SELECT x ( x ) FROM x WHERE x > 1 ; 
SET LOCAL max_parallel_workers_per_gather = 1 ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x WHERE x = 1 ; 
SELECT x ( x ) FROM x WHERE x = 1 ; 
EXPLAIN ( costs off ) SELECT x , ( SELECT x ( x ) FROM x WHERE x > x ) AS gt FROM x ; 
SELECT x , ( SELECT x ( x ) FROM x WHERE x > x ) AS gt FROM x ; 
EXPLAIN ( costs off ) SELECT DISTINCT x ( x ) FROM x ; 
SELECT DISTINCT x ( x ) FROM x ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x ORDER BY 1 ; 
SELECT x ( x ) FROM x ORDER BY 1 ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x ORDER BY x ( x ) ; 
SELECT x ( x ) FROM x ORDER BY x ( x ) ; 
EXPLAIN ( costs off ) SELECT x ( x ) FROM x ORDER BY x ( x ) + 1 ; 
SELECT x ( x ) FROM x ORDER BY x ( x ) + 1 ; 
EXPLAIN ( costs off ) SELECT x ( x ) , x ( 1 , 1 ) AS g FROM x ORDER BY x DESC ; 
SELECT x ( x ) , x ( 1 , 1 ) AS g FROM x ORDER BY x DESC ; 
EXPLAIN ( costs off ) SELECT x ( 1 ) FROM x ; 
SELECT x ( 1 ) FROM x ; 
CREATE INDEX x ON x ( x DESC ) ; 
CREATE INDEX x ON x ( x ) WHERE x IS NOT NULL ; 
EXPLAIN ( costs off ) SELECT x ( x ) , x ( x ) FROM x ; 
EXPLAIN ( costs off ) SELECT DISTINCT x ( x ) , x ( x ) FROM x ; 
SELECT DISTINCT x ( x ) , x ( x ) FROM x ; 
SELECT x ( x ( x ) ) FROM x ; 
SELECT ( SELECT x ( x ( x ) ) FROM x ) FROM x ; 
CREATE TEMP TABLE x ( x INT , x INT , x INT , x INT , PRIMARY KEY ( x , x ) ) ; 
CREATE TEMP TABLE x ( x INT , x INT , x INT , PRIMARY KEY ( x , x ) ) ; 
CREATE TEMP TABLE x ( x INT , x INT , x INT , PRIMARY KEY ( x , x ) DEFERRABLE ) ; 
EXPLAIN ( costs off ) SELECT * FROM x GROUP BY x , x , x , x ; 
EXPLAIN ( costs off ) SELECT x , x FROM x GROUP BY x , x , x ; 
EXPLAIN ( costs off ) SELECT * FROM x GROUP BY x , x , x ; 
EXPLAIN ( costs off ) SELECT * FROM ONLY x GROUP BY x , x , x , x ; 
CREATE TEMP TABLE x ( x INT , x INT , x INT , x INT , PRIMARY KEY ( x , x ) ) PARTITION BY list ( a ) ; 
CREATE TEMP TABLE x PARTITION OF x FOR VALUES IN ( 1 ) ; 
SELECT x ( x ORDER BY x ) FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ) v ( a , b ) ; 
SELECT x ( x ORDER BY x DESC ) FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ) v ( a , b ) ; 
SELECT x ( DISTINCT x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) , ( 1 ) ) v ( a ) ; 
SELECT x ( DISTINCT x ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) , ( 1 ) ) v ( a ) ; 
SELECT x ( DISTINCT x ORDER BY x DESC ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) , ( 1 ) ) v ( a ) ; 
SELECT x ( DISTINCT x ORDER BY x DESC NULLS LAST ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( NULL ) , ( 1 ) ) v ( a ) ; 
SELECT x ( x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ; 
SELECT x ( DISTINCT x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( DISTINCT x , x , x ORDER BY x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
~~SELECT x ( DISTINCT x , x , x ORDER BY x USING < , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
~~SELECT x ( DISTINCT x , x , x ORDER BY x USING < ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
~~SELECT x ( DISTINCT x , x , x ORDER BY x , x USING < , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
CREATE VIEW x AS SELECT x ( x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ; 
CREATE OR REPLACE VIEW x AS SELECT x ( DISTINCT x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
CREATE OR REPLACE VIEW x AS SELECT x ( DISTINCT x , x , x ORDER BY x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
CREATE OR REPLACE VIEW x AS SELECT x ( x , x , x ORDER BY x + 1 ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ; 
CREATE OR REPLACE VIEW x AS SELECT x ( x , x , x ORDER BY x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ; 
~~CREATE OR REPLACE VIEW x AS SELECT x ( x , x , x ORDER BY x USING < ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) ; 
~~CREATE OR REPLACE VIEW x AS SELECT x ( DISTINCT x , x , x ORDER BY x , x USING < , x ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( DISTINCT x , x , x ORDER BY x ) FROM ( VALUES ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( DISTINCT x , x , x ORDER BY x , x + 1 ) FROM ( VALUES ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( DISTINCT x , x , x ORDER BY x , x , x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( DISTINCT x , x , x ORDER BY x , x ) FROM ( VALUES ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( x , 'x' ) FROM ( VALUES ( 'x' ) , ( 'x' ) , ( 'x' ) ) g ( a ) ; 
SELECT x ( x , 'x' ) FROM ( VALUES ( 'x' ) , ( NULL ) , ( 'x' ) , ( 'x' ) ) g ( a ) ; 
SELECT x ( x , 'x' ) FROM ( VALUES ( NULL ) , ( NULL ) , ( 'x' ) , ( 'x' ) ) g ( a ) ; 
SELECT x ( x , 'x' ) FROM ( VALUES ( NULL ) , ( NULL ) ) g ( a ) ; 
SELECT x ( x , 'x' ) FROM x ; 
INSERT INTO x VALUES ( x ( 'x' , 'x' ) ) ; 
SELECT x ( x , NULL ) FROM x ; 
SELECT x ( x , x ( 'x' , 'x' ) ) FROM x ; 
SELECT x ( x ) FILTER ( WHERE x > 1 ) FROM x ; 
SELECT x ( 1 / x ) FILTER ( WHERE x > 1 ) FROM x ; 
SELECT x ( x COLLATE C" ) FILTER ( WHERE ( x COLLATE POSIX" ) > 'x' ) FROM ( VALUES ( 'x' , 'x' ) ) AS v ( foo , bar ) ; 
~~SELECT x ( DISTINCT x , x , x ORDER BY x , x USING < , x ) FILTER ( WHERE x > 1 ) FROM ( VALUES ( 1 , 1 , 'x' ) , ( 1 , NULL , NULL ) , ( 1 , 1 , 'x' ) , ( 1 , 1 , 'x' ) ) v ( a , b , c ) , x ( 1 , 1 ) i ; 
SELECT x ( 0.500000 ) WITHIN GROUP ( ORDER BY x ) FROM x ; 
SELECT x ( 0.500000 ) WITHIN GROUP ( ORDER BY x ) , x ( x ) FROM x ; 
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) ; 
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) ; 
SELECT x ( ARRAY [ 1 , 0.100000 , 0.250000 , 0.500000 , 0.750000 , 0.900000 , 1 ] ) WITHIN GROUP ( ORDER BY x ) FROM x ; 
SELECT x ( ARRAY [ 1 , 0.250000 , 0.500000 , 0.750000 , 1 ] ) WITHIN GROUP ( ORDER BY x ) FROM x ; 
SELECT x ( ARRAY [ [ NULL , 1 , 0.500000 ] , [ 0.750000 , 0.250000 , NULL ] ] ) WITHIN GROUP ( ORDER BY x ) FROM x ; 
SELECT x ( ARRAY [ 1 , 1 , 0.250000 , 0.750000 , 0.500000 , 1 , 0.300000 , 0.320000 , 0.350000 , 0.380000 , 0.400000 ] ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ; 
SELECT x ( x ( 1 ) WITHIN GROUP ( ORDER BY x COLLATE POSIX" ) ) FROM ( VALUES ( 'x' ) , ( 'x' ) ) v ( x ) ; 
SELECT x ( x ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ; 
SELECT ARRAY ( SELECT x ( x ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 0.300000 ) , ( 0.700000 ) ) v ( a ) GROUP BY x ) FROM x ( 1 , 1 ) g ( x ) ; 
SELECT x ( x ( x ) ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ; 
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 'x' ) , ( 'x' ) ) v ( x ) ; 
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x , x ) FROM x ; 
SELECT x ( 'x' ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ; 
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM x ( 1 , 1 ) x ; 
SELECT x ( VARIADIC ARRAY [ x , x ] ) FROM x ; 
BEGIN WORK ; 
CREATE TYPE avg_state AS ( total BIGINT , count BIGINT ) ; 
$$$$$$$$$$$$SELECT x ( x ) , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) t ( one ) ; 
SELECT x ( DISTINCT x ) , x ( DISTINCT x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) ) t ( one ) ; 
SELECT x ( DISTINCT x ) , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) t ( one ) ; 
SELECT x ( x ) FILTER ( WHERE x > 1 ) , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) ) t ( one ) ; 
SELECT x ( x ) , x ( x ) FROM ( VALUES ( 1 , 1 ) , ( 1 , 1 ) ) t ( one , two ) ; 
SELECT x ( 1 ) WITHIN GROUP ( ORDER BY x ) , x ( 1 ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) t ( a ) ; 
$$$$$$$$SELECT x ( x ) , x ( x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) t ( one ) ; 
$$BEGIN ISOLATION LEVEL REPEATABLE READ ; 
$$ALTER TABLE x SET ( parallel_workers = 1 ) ; 
SET LOCAL parallel_setup_cost = 1 ; 
EXPLAIN ( COSTS OFF ) SELECT x ( x ) FROM x ; 
SET parallel_setup_cost = 1 ; 
SET parallel_tuple_cost = 1 ; 
SET min_parallel_table_scan_size = 1 ; 
SET max_parallel_workers_per_gather = 1 ; 
SET enable_indexonlyscan = off ; 
SELECT x ( x ) WITHIN GROUP ( ORDER BY x ) FROM ( VALUES ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) , ( 1 ) ) v ( x ) GROUP BY ( x ) ORDER BY 1 ; 
SELECT x ( x ORDER BY x ) FROM ( VALUES ( 1 , NULL ) ) AS d ( x , y ) ; 
SELECT x ( x ORDER BY x ) FROM ( VALUES ( 1 , 1 ) ) AS d ( x , y ) ; 
SELECT x || 'x' , CASE x || 'x' WHEN 'x' THEN 1 ELSE 1 END , x ( * ) FROM x ( ARRAY [ 'x' , 'x' ] ) u ( v ) GROUP BY x || 'x' ORDER BY 1 ; 
SELECT x || 'x' , CASE WHEN x || 'x' = 'x' THEN 1 ELSE 1 END , x ( * ) FROM x ( ARRAY [ 'x' , 'x' ] ) u ( v ) GROUP BY x || 'x' ORDER BY 1 ; 
EXPLAIN ( costs off ) SELECT 1 FROM x WHERE ( x , x ) IN ( SELECT x , x FROM x ) ; 
~~~~~~~~~~~~~~~~~~~~~~~~~CREATE TABLE x ( x SERIAL PRIMARY KEY , x INT , x TEXT ) ; 
INSERT INTO x ( x , x ) VALUES ( 1 , x ( 'x' , 1 ) ) ; 
DELETE FROM x AS x WHERE x . x > 1 ; 
DELETE FROM x x WHERE x . x > 1 ; 
DELETE FROM x WHERE x > 1 ; 
CREATE TABLE x ( x date ) ; 
SELECT x AS Fifteen" FROM x ; 
SELECT x AS Nine" FROM x WHERE x < 'x' ; 
SELECT x AS Three" FROM x WHERE x BETWEEN 'x' AND 'x' ; 
SELECT x 'x' ; 
SET datestyle TO mdy ; 
SELECT x - x 'x' AS Days From 2K" FROM x ; 
SELECT x - x 'x' AS Days From Epoch" FROM x ; 
SELECT x 'x' - x 'x' AS One day" ; 
SELECT x 'x' - x 'x' AS Two days" ; 
SELECT x ( 1 , 1 , 1 ) ; 
SELECT x ( 1 , 1 , 0.000000 ) ; 
SELECT x ( 1 , 1 , 100.099998 ) ; 
SELECT x ( 1 , 1 , 2.100000 ) ; 
CREATE TABLE x ( x INT , x INT , x CHAR ( 1 ) , x CHAR ) ; 
INSERT INTO x VALUES ( 1 , 1 , 'x' , 'x' ) ; 
SELECT x , x ( * ) FROM x GROUP BY x . x ORDER BY x ; 
SELECT x ( * ) FROM x GROUP BY x . x ORDER BY x ; 
SELECT x ( * ) FROM x GROUP BY x ORDER BY x ; 
SELECT x . x , x ( * ) FROM x GROUP BY x ORDER BY x ; 
SELECT x FROM x ORDER BY x ; 
SELECT x ( * ) FROM x GROUP BY x ORDER BY x DESC ; 
SELECT x ( * ) FROM x ORDER BY 1 DESC ; 
SELECT x , x ( * ) FROM x GROUP BY 1 ORDER BY 1 ; 
SELECT x , x ( * ) FROM x GROUP BY 1 ; 
SELECT x ( * ) FROM x x , x y WHERE x . x = x . x GROUP BY x ORDER BY x ; 
SELECT x , x FROM x ORDER BY x ; 
SELECT x / 1 , x / 1 FROM x ORDER BY x / 1 ; 
SELECT x / 1 , x / 1 FROM x GROUP BY x / 1 ORDER BY x / 1 ; 
SELECT x . x , x ( * ) FROM x x , x y WHERE x . x = x . x GROUP BY x . x ORDER BY x . x ; 
SELECT x ( * ) FROM x x , x y WHERE x . x = x . x GROUP BY x . x ORDER BY x . x ; 
SELECT x ( x ) FROM x GROUP BY x ORDER BY x ; 
SELECT x ( x ) FROM x GROUP BY x / 1 ORDER BY x / 1 ; 
SELECT x ( x . x ) , x ( x ) FROM x GROUP BY x ( x ) ORDER BY x ( x ) ; 
SELECT x FROM x ORDER BY x ( x ) ; 
SELECT x ( x ) FROM x GROUP BY ( x + 1 ) / 1 ORDER BY ( x + 1 ) / 1 DESC ; 
SELECT x ( x . x ) FROM x x , x y WHERE x . x = x . x GROUP BY x / 1 ORDER BY x / 1 ; 
SELECT x . x / 1 , x ( x . x ) FROM x x , x y WHERE x . x = x . x GROUP BY x . x / 1 ORDER BY x . x / 1 ; 
SELECT x ( x ) FROM x x , x y WHERE x . x = x . x GROUP BY x . x / 1 ; 
CREATE TABLE x ( x INTEGER , x INTEGER , x TEXT ) ; 
CREATE TABLE x ( x INTEGER , x INTEGER ) ; 
INSERT INTO x VALUES ( NULL , NULL , 'x' ) ; 
INSERT INTO x VALUES ( NULL , 1 , 'x' ) ; 
INSERT INTO x VALUES ( NULL , NULL ) ; 
CREATE TEMP TABLE x ( ) ; 
SELECT 'x' AS xxx" , * FROM x AS tx ; 
SELECT 'x' AS xxx" , * FROM x tx ; 
SELECT 'x' AS xxx" , * FROM x AS t1 ( a , b , c ) ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) , x t2 ( d , e ) ; 
SELECT 'x' AS xxx" , x . x , x . x FROM x t1 ( a , b , c ) , x t2 ( d , e ) WHERE x . x = x . x ; 
SELECT 'x' AS xxx" , * FROM x CROSS JOIN x ; 
SELECT 'x' AS xxx" , x , x , x FROM x CROSS JOIN x ; 
SELECT 'x' AS xxx" , x . x , x , x FROM x t1 CROSS JOIN x t2 ; 
SELECT 'x' AS xxx" , x , x , x FROM ( x CROSS JOIN x ) AS tx ( ii , jj , tt , ii2 , kk ) ; 
SELECT 'x' AS xxx" , x . x , x . x , x . x FROM ( x t1 ( a , b , c ) CROSS JOIN x t2 ( d , e ) ) AS tx ( ii , jj , tt , ii2 , kk ) ; 
SELECT 'x' AS xxx" , * FROM x CROSS JOIN x a CROSS JOIN x b ; 
SELECT 'x' AS xxx" , * FROM x INNER JOIN x USING ( i ) ; 
SELECT 'x' AS xxx" , * FROM x JOIN x USING ( i ) ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) JOIN x t2 ( a , d ) USING ( a ) ORDER BY x , x ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) JOIN x t2 ( a , b ) USING ( b ) ORDER BY x , x . x ; 
SELECT 'x' AS xxx" , * FROM x NATURAL JOIN x ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) NATURAL JOIN x t2 ( a , d ) ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b , c ) NATURAL JOIN x t2 ( d , a ) ; 
SELECT 'x' AS xxx" , * FROM x t1 ( a , b ) NATURAL JOIN x t2 ( a ) ; 
SELECT 'x' AS xxx" , * FROM x JOIN x ON ( x . x = x . x ) ; 
SELECT 'x' AS xxx" , * FROM x JOIN x ON ( x . x <= x . x ) ; 
SELECT 'x' AS xxx" , * FROM x LEFT OUTER JOIN x USING ( i ) ORDER BY x , x , x ; 
SELECT 'x' AS xxx" , * FROM x LEFT JOIN x USING ( i ) ORDER BY x , x , x ; 
SELECT 'x' AS xxx" , * FROM x RIGHT OUTER JOIN x USING ( i ) ; 
SELECT 'x' AS xxx" , * FROM x RIGHT JOIN x USING ( i ) ; 
SELECT 'x' AS xxx" , * FROM x FULL OUTER JOIN x USING ( i ) ORDER BY x , x , x ; 
SELECT 'x' AS xxx" , * FROM x FULL JOIN x USING ( i ) ORDER BY x , x , x ; 
SELECT 'x' AS xxx" , * FROM x LEFT JOIN x USING ( i ) WHERE ( x = 1 ) ; 
CREATE TEMP TABLE x ( x INT , x INT ) ; 
SELECT * FROM x LEFT JOIN x ON ( x = x AND x IS NOT NULL ) ; 
SELECT * FROM ( x LEFT JOIN x ON ( x = x ) ) LEFT JOIN x xx ( xx1 , xx2 ) ON ( x = x ) ; 
SELECT * FROM ( x LEFT JOIN x ON ( x = x ) ) LEFT JOIN x xx ( xx1 , xx2 ) ON ( x = x AND x IS NOT NULL ) ; 
SELECT * FROM ( x LEFT JOIN x ON ( x = x ) ) LEFT JOIN x xx ( xx1 , xx2 ) ON ( x = x ) WHERE ( x IS NOT NULL ) ; 
SELECT x ( * ) FROM x a WHERE x IN ( SELECT x FROM x b JOIN x c USING ( unique1 ) WHERE x . x = 1 ) ; 
SELECT x ( * ) FROM x x WHERE x . x IN ( SELECT x . x FROM x a , x b WHERE x . x = x . x ) AND x . x = 1 AND x . x IN ( SELECT x . x FROM x aa , x bb WHERE x . x = x . x ) ; 
SET geqo = ON ; 
SET geqo_threshold = 1 ; 
EXPLAIN ( costs off ) SELECT x , x , x , x FROM x RIGHT JOIN x ON x = x WHERE x < x AND x IS NULL ; 
SELECT x , x , x , x FROM x RIGHT JOIN x ON x = x WHERE x < x AND x IS NULL ; 
EXPLAIN ( costs off ) SELECT * FROM x FULL JOIN ( SELECT * FROM x ORDER BY x . x DESC , x . x ASC ) j2_tbl ON x . x = x . x AND x . x = x . x ; 
SELECT * FROM x FULL JOIN ( SELECT * FROM x ORDER BY x . x DESC , x . x ASC ) j2_tbl ON x . x = x . x AND x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM ( SELECT * FROM x x ORDER BY x . x , x . x , x . x ) x LEFT JOIN ( SELECT * FROM x y ORDER BY x . x ) y ON x . x = x . x AND x . x = x . x AND x . x = x . x ; 
SELECT x ( * ) FROM ( SELECT * FROM x x ORDER BY x . x , x . x , x . x ) x LEFT JOIN ( SELECT * FROM x y ORDER BY x . x ) y ON x . x = x . x AND x . x = x . x AND x . x = x . x ; 
DELETE FROM x USING x table1 WHERE x . x = x . x ; 
DELETE FROM x USING x JOIN x USING ( a ) WHERE x . x > x . x ; 
DELETE FROM x USING x t3_other WHERE x . x = x . x AND x . x = x . x ; 
SELECT * FROM x LEFT JOIN x ON ( x . x = x . x ) ; 
SELECT x . x FROM x JOIN x ON ( x . x = x . x ) ; 
CREATE TEMP TABLE x ( x int4 , x int4 ) ; 
SET enable_hashjoin TO off ; 
SET enable_nestloop TO off ; 
SELECT x . * , x . * FROM x LEFT JOIN x ON x . x = x . x ; 
SELECT x . * , x . * FROM x RIGHT JOIN x ON x . x = x . x ; 
RESET enable_hashjoin ; 
RESET enable_nestloop ; 
SET work_mem TO 'x' ; 
SET enable_mergejoin TO off ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x a , x b WHERE x . x = x . x AND ( x . x % 1 ) < 1 ; 
SELECT x ( * ) FROM x a , x b WHERE x . x = x . x AND ( x . x % 1 ) < 1 ; 
RESET work_mem ; 
RESET enable_mergejoin ; 
INSERT INTO x SELECT x , x ( 'x' , 1 ) FROM x ( 1 , 1 ) x ; 
INSERT INTO x VALUES ( 1 ) , ( 1 ) , ( 1 ) ; 
CREATE TEMP TABLE x ( x INT , x INT , x INT ) ; 
SELECT * FROM x , x WHERE x . x = x . x AND x . x = x . x - x . x ; 
SELECT * FROM x LEFT JOIN x ON ( x = x ) LEFT JOIN x ON ( x = x ) WHERE x = 1 ; 
$PREPARE foo ( bool ) AS SELECT x ( * ) FROM x a LEFT JOIN x b ON ( x . x = x . x AND EXISTS ( SELECT 1 FROM x c WHERE x . x = x . x AND 1 ) ) ; 
EXECUTE foo ( TRUE ) ; 
EXECUTE foo ( FALSE ) ; 
SET enable_mergejoin = 1 ; 
SET enable_hashjoin = 1 ; 
SET enable_nestloop = 1 ; 
CREATE TEMP TABLE x ( x INTEGER ) ; 
CREATE TEMP TABLE x ( x INTEGER , x INTEGER ) ; 
SELECT * FROM x LEFT JOIN x ON x = x AND x = x AND x = x ; 
CREATE TYPE mycomptype AS ( id INT , v BIGINT ) ; 
CREATE TEMP TABLE x ( x mycomptype ) ; 
EXPLAIN ( costs off ) SELECT x . x , x . x FROM x a , x b WHERE x . x = x . x ; 
SELECT x . x , x ( x . * ) FROM x t1 LEFT JOIN x t2 ON ( x . x = x . x ) GROUP BY x . x ORDER BY 1 ; 
SELECT x . x , x ( x . * ) FROM x t1 LEFT JOIN ( SELECT * FROM x ) t2 ON ( x . x = x . x ) GROUP BY x . x ORDER BY 1 ; 
SELECT x . x , x ( x . * ) FROM x t1 LEFT JOIN ( SELECT * FROM x OFFSET 1 ) t2 ON ( x . x = x . x ) GROUP BY x . x ORDER BY 1 ; 
SELECT x . x , x ( x . * ) FROM x t1 LEFT JOIN ( SELECT x , CASE WHEN x = 1 THEN 1 ELSE x END AS q2 FROM x ) t2 ON ( x . x = x . x ) GROUP BY x . x ORDER BY 1 ; 
CREATE TEMP TABLE x ( x CHAR NOT NULL , CONSTRAINT a_pk PRIMARY KEY ( x ) ) ; 
CREATE TEMP TABLE x ( x CHAR NOT NULL , x INTEGER NOT NULL , CONSTRAINT b_pk PRIMARY KEY ( x , x ) ) ; 
INSERT INTO x ( x , x ) VALUES ( 'x' , 1 ) ; 
EXPLAIN ( COSTS OFF ) SELECT x , x FROM ( SELECT COALESCE ( x , 1 ) AS qq FROM x a ) AS ss1 FULL OUTER JOIN ( SELECT COALESCE ( x , 1 ) AS qq FROM x b ) AS ss2 USING ( qq ) INNER JOIN x c ON x = x ; 
SELECT x , x FROM ( SELECT COALESCE ( x , 1 ) AS qq FROM x a ) AS ss1 FULL OUTER JOIN ( SELECT COALESCE ( x , 1 ) AS qq FROM x b ) AS ss2 USING ( qq ) INNER JOIN x c ON x = x ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x BOOLEAN , x BOOLEAN ) ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x INT , x BOOLEAN , x BOOLEAN , FOREIGN KEY ( x ) REFERENCES x ( x ) ) ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x INT , x BOOLEAN , FOREIGN KEY ( x ) REFERENCES x ( x ) ) ; 
INSERT INTO x VALUES ( 1 , TRUE , TRUE ) ; 
INSERT INTO x VALUES ( 1 , TRUE , FALSE ) ; 
INSERT INTO x VALUES ( 1 , FALSE , FALSE ) ; 
INSERT INTO x VALUES ( 1 , 1 , TRUE , TRUE ) ; 
INSERT INTO x VALUES ( 1 , 1 , TRUE , FALSE ) ; 
INSERT INTO x VALUES ( 1 , 1 , FALSE , FALSE ) ; 
INSERT INTO x VALUES ( 1 , 1 , TRUE ) ; 
INSERT INTO x VALUES ( 1 , 1 , FALSE ) ; 
SELECT * FROM x a FULL JOIN x b ON TRUE ; 
SELECT * FROM x a FULL JOIN x b ON FALSE ; 
CREATE TEMP TABLE x AS SELECT 1 AS q1 ; 
CREATE TEMP TABLE x AS SELECT 1 AS q2 ; 
EXPLAIN ( costs off ) SELECT x . x , x . x , x . x , x . x FROM x t1 INNER JOIN x i1 LEFT JOIN ( SELECT x . x , x . x , 1 AS d1 FROM ( SELECT 1 , 1 FROM x ) v1 ( x1 , x2 ) LEFT JOIN ( SELECT 1 , 1 FROM x ) v2 ( y1 , y2 ) ON x . x = x . x ) subq1 ON ( x . x = x . x ) ON ( x . x = x . x ) LEFT JOIN x t2 ON ( x . x = x . x ) WHERE x . x < 1 AND x . x > x . x ; 
SELECT x . x , x . x , x . x , x . x FROM x t1 INNER JOIN x i1 LEFT JOIN ( SELECT x . x , x . x , 1 AS d1 FROM ( SELECT 1 , 1 FROM x ) v1 ( x1 , x2 ) LEFT JOIN ( SELECT 1 , 1 FROM x ) v2 ( y1 , y2 ) ON x . x = x . x ) subq1 ON ( x . x = x . x ) ON ( x . x = x . x ) LEFT JOIN x t2 ON ( x . x = x . x ) WHERE x . x < 1 AND x . x > x . x ; 
EXPLAIN ( costs off ) SELECT x . x , x . x , x . x , x . x FROM x t1 INNER JOIN x i1 LEFT JOIN ( SELECT x . x , x . x , 1 AS d1 FROM ( VALUES ( 1 , 1 ) ) v1 ( x1 , x2 ) LEFT JOIN ( VALUES ( 1 , 1 ) ) v2 ( y1 , y2 ) ON x . x = x . x ) subq1 ON ( x . x = x . x ) ON ( x . x = x . x ) LEFT JOIN x t2 ON ( x . x = x . x ) WHERE x . x < 1 AND x . x > x . x ; 
SELECT x . x , x . x , x . x , x . x FROM x t1 INNER JOIN x i1 LEFT JOIN ( SELECT x . x , x . x , 1 AS d1 FROM ( VALUES ( 1 , 1 ) ) v1 ( x1 , x2 ) LEFT JOIN ( VALUES ( 1 , 1 ) ) v2 ( y1 , y2 ) ON x . x = x . x ) subq1 ON ( x . x = x . x ) ON ( x . x = x . x ) LEFT JOIN x t2 ON ( x . x = x . x ) WHERE x . x < 1 AND x . x > x . x ; 
$$EXPLAIN ( costs off ) SELECT x FROM x , x ( 1 ) x WHERE x = x ; 
EXPLAIN ( costs off ) SELECT x FROM x , LATERAL x ( 1 ) x WHERE x = x ; 
EXPLAIN ( costs off ) SELECT x , x FROM x JOIN x ( 1 ) x ON x = x ; 
EXPLAIN ( costs off ) SELECT x , x FROM x LEFT JOIN x ( 1 ) x ON x = x ; 
EXPLAIN ( costs off ) SELECT x , x FROM x RIGHT JOIN x ( 1 ) x ON x = x ; 
EXPLAIN ( costs off ) SELECT x , x FROM x FULL JOIN x ( 1 ) x ON x = x ; 
EXPLAIN ( costs off ) SELECT x FROM x , x ( 1 ) x WHERE x = 1 ; 
$$$$SELECT * FROM x ( 1 , 1 ) ; 
DROP FUNCTION x ( BIGINT , BIGINT ) ; 
EXPLAIN ( costs off ) SELECT * FROM x a JOIN x b ON ( x . x = 1 AND x . x = 1 ) OR ( x . x = 1 AND x . x = 1 ) ; 
EXPLAIN ( costs off ) SELECT * FROM x a JOIN x b ON ( x . x = 1 AND x . x = 1 ) OR ( ( x . x = 1 OR x . x = 1 ) AND x . x = 1 ) ; 
EXPLAIN ( costs off ) SELECT x ( * ) FROM x a JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = x . x AND x . x = x . x JOIN x ON x . x = x ; 
SELECT x ( * ) FROM x a JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = x . x AND x . x = x . x JOIN x ON x . x = x ; 
EXPLAIN ( costs off ) SELECT x . x FROM x a JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = 1 AND x . x = x . x JOIN x i1 ON x . x = x RIGHT JOIN x i2 ON x . x = x . x ORDER BY 1 ; 
SELECT x . x FROM x a JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = 1 AND x . x = x . x JOIN x i1 ON x . x = x RIGHT JOIN x i2 ON x . x = x . x ORDER BY 1 ; 
EXPLAIN ( costs off ) SELECT * FROM ( VALUES ( 1 , ARRAY [ 1 , 1 ] ) , ( 1 , ARRAY [ 1 , 1 ] ) ) AS v1 ( v1x , v1ys ) LEFT JOIN ( VALUES ( 1 , 1 ) , ( 1 , 1 ) ) AS v2 ( v2x , v2y ) ON x = x JOIN x ( x ) AS u1 ( u1y ) ON x = x ; 
SELECT * FROM ( VALUES ( 1 , ARRAY [ 1 , 1 ] ) , ( 1 , ARRAY [ 1 , 1 ] ) ) AS v1 ( v1x , v1ys ) LEFT JOIN ( VALUES ( 1 , 1 ) , ( 1 , 1 ) ) AS v2 ( v2x , v2y ) ON x = x JOIN x ( x ) AS u1 ( u1y ) ON x = x ; 
EXPLAIN ( costs off ) SELECT x , x , x , x FROM x a LEFT JOIN x b ON x = x WHERE COALESCE ( x , 1 ) = x AND x = COALESCE ( x , 1 ) ; 
SELECT x , x , x , x FROM x a LEFT JOIN x b ON x = x WHERE COALESCE ( x , 1 ) = x AND x = COALESCE ( x , 1 ) ; 
EXPLAIN ( costs off ) SELECT x , x , CASE WHEN x IS NULL THEN x ELSE 1 END FROM x a LEFT JOIN x b ON x = x WHERE ( CASE WHEN x IS NULL THEN x ELSE 1 END ) = 1 ; 
SELECT x , x , CASE WHEN x IS NULL THEN x ELSE 1 END FROM x a LEFT JOIN x b ON x = x WHERE ( CASE WHEN x IS NULL THEN x ELSE 1 END ) = 1 ; 
EXPLAIN ( costs off ) SELECT x . x , x . x , x . x , COALESCE ( x . x , x . x ) FROM x a LEFT JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = COALESCE ( x . x , x . x ) WHERE x . x < 1 AND COALESCE ( x . x , x . x ) = 1 ; 
SELECT x . x , x . x , x . x , COALESCE ( x . x , x . x ) FROM x a LEFT JOIN x b ON x . x = x . x LEFT JOIN x c ON x . x = COALESCE ( x . x , x . x ) WHERE x . x < 1 AND COALESCE ( x . x , x . x ) = 1 ; 
SELECT * FROM x t1 INNER JOIN x i8 ON x . x = 1 RIGHT JOIN x t2 ON x . x = 'x' LEFT JOIN x i4 ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT * FROM ( SELECT 1 AS id ) AS xx LEFT JOIN ( x AS a1 FULL JOIN ( SELECT 1 AS id ) AS yy ON ( x . x = x . x ) ) ON ( x . x = COALESCE ( x . x ) ) ; 
SELECT * FROM ( SELECT 1 AS id ) AS xx LEFT JOIN ( x AS a1 FULL JOIN ( SELECT 1 AS id ) AS yy ON ( x . x = x . x ) ) ON ( x . x = COALESCE ( x . x ) ) ; 
EXPLAIN ( costs off ) SELECT * FROM x a LEFT JOIN x b ON x = x WHERE x = 1 ; 
EXPLAIN ( costs off ) SELECT * FROM x a FULL JOIN x b USING ( unique2 ) WHERE x = 1 ; 
SELECT x . x , x . x FROM x a LEFT JOIN x b ON x . x = COALESCE ( x . x , 1 ) WHERE COALESCE ( x . x , 1 ) > 1 ; 
CREATE TEMP TABLE x ( x INT PRIMARY KEY , x INT ) ; 
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , NULL ) ; 
INSERT INTO x VALUES ( 1 , 1 ) , ( 1 , 1 ) , ( 1 , 1 ) ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN x ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( x LEFT JOIN x ON x . x = x . x ) ON ( x . x = x . x ) ; 
EXPLAIN ( costs off ) SELECT x FROM x WHERE x IN ( SELECT x . x FROM x LEFT JOIN x ON x . x = x . x ) ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT * FROM x GROUP BY x . x , x . x ) s ON x . x = x . x AND x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT DISTINCT * FROM x ) s ON x . x = x . x AND x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT * FROM x GROUP BY x . x , x . x ) s ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT DISTINCT * FROM x ) s ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x . * FROM x LEFT JOIN ( SELECT x FROM x UNION SELECT x FROM x ) s ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT x . * FROM x i8 LEFT JOIN ( SELECT x FROM x GROUP BY x ) i4 ON x . x = x . x ; 
EXPLAIN ( costs off ) SELECT 1 FROM ( SELECT x . x FROM x LEFT JOIN x ON x . x = x . x ) q , LATERAL x ( 1 , x . x ) gs ( i ) WHERE x . x = x . x ; 
CREATE TEMP TABLE x ( x INT UNIQUE , x INT ) ; 
SELECT x . * FROM x p LEFT JOIN x c ON ( x . x = x . x ) ; 
EXPLAIN ( costs off ) SELECT x . * FROM x p LEFT JOIN x c ON ( x . x = x . x ) ; 
SELECT x . * , x FROM x p LEFT JOIN ( SELECT x . * , TRUE AS linked FROM x c ) AS ss ON ( x . x = x . x ) ; 
EXPLAIN ( costs off ) SELECT x . * , x FROM x p LEFT JOIN ( SELECT x . * , TRUE AS linked FROM x c ) AS ss ON ( x . x = x . x ) ; 
SELECT x . * FROM x p LEFT JOIN x c ON ( x . x = x . x ) WHERE x . x = 1 AND x . x = 1 ; 
EXPLAIN ( costs off ) SELECT x . * FROM x p LEFT JOIN x c ON ( x . x = x . x ) WHERE x . x = 1 AND x . x = 1 ; 
SELECT x . * FROM ( x p LEFT JOIN x c ON ( x . x = x . x ) ) JOIN x x ON x . x = x . x WHERE x . x = 1 AND x . x = 1 ; 
